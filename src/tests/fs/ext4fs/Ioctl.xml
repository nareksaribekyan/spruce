<TestSet Name="Ioctl">
        <Requires>sys/ioctl.h</Requires>
        <Requires>linux/fs.h</Requires>
        <Requires>fcntl.h</Requires>
        <Requires>ext4.hpp</Requires>   
        <Requires>pwd.h</Requires>
        <Requires>linux/version.h</Requires>
        <Requires>inttypes.h</Requires>
        <Requires>ext4.hpp</Requires>
        <Requires>PartitionManager.hpp</Requires>
        <Requires>attr/xattr.h</Requires>    
        
        <Test Name="SetFlagsGetFlags" FaultSimulationReady="true">              
                <Description>Try to set and get some flag values.</Description>
                <File count="1"/>
                <Code>
                        int set_flags = 0;
                        // Set 'EXT4_IMMUTABLE_FL' flag, assuming that created file is not immutable
                        if(PartitionManager:: IsOptionEnabled("-t ext2", true) || PartitionManager:: IsOptionEnabled("-t ext3", true))
                                set_flags = EXT4_IMMUTABLE_FL | EXT4_SECRM_FL;
                        else
                                set_flags = EXT4_EXTENTS_FL | EXT4_IMMUTABLE_FL | EXT4_SECRM_FL; // We may NOT clear the extents flag...
                                
                        int get_flags = 0;
                        
                        // Backup the old values just in case
                        int old_flags;  
                        Fail( ioctl(FDs[0], EXT4_IOC_GETFLAGS, &old_flags ) == -1 , "Error backing up old values.");
                        
                        // Set our testing flag values
                        Fail ( ioctl(FDs[0], EXT4_IOC_SETFLAGS, &set_flags ) == -1, "Error setting new flag values.");
                
                        // Get the flags back
                        Fail ( ioctl(FDs[0], EXT4_IOC_GETFLAGS, &get_flags ) == -1, "Error getting flag values back.");
                        
                        // Restore the original flags
                        Fail ( ioctl(FDs[0], EXT4_IOC_SETFLAGS, &old_flags ) == -1, "Error restoring old flag values.");
                        
                        // Compare them
                        Check ( get_flags != set_flags, "Set and Get flags mismatch");
                </Code>
        </Test>
         <Test Name="SetAllFlags" FaultSimulationReady="true">              
                <Description>Try to set and get some flag values.</Description>
                <Dir count="1"/>
                <Code>   
                        Skip(!PartitionManager::NoOptionsEnabled(), "These tests should run only when no options are provided.");                  
                        int set_flags = EXT4_EXTENTS_FL | EXT4_IMMUTABLE_FL | EXT4_SECRM_FL | EXT4_SYNC_FL | EXT4_APPEND_FL | EXT4_NOATIME_FL | EXT4_DIRSYNC_FL;                     
                        Fail ( ioctl(DirDs[0], EXT4_IOC_SETFLAGS, &set_flags ) == -1, "Error setting new flag values.");
                     
                </Code>
        </Test>
        <Test Name="SetJournalDataFlag" FaultSimulationReady="true">              
                <Description>Try to set EXT4_JOURNAL_DATA_FL flag.</Description>
                <Dir count="1"/>
                <Code>  
                        Skip(!PartitionManager::NoOptionsEnabled(), "These tests should run only when no options are provided.");        
                        int set_flags = EXT4_EXTENTS_FL | EXT4_JOURNAL_DATA_FL;                     
                        Fail ( ioctl(DirDs[0], EXT4_IOC_SETFLAGS, &set_flags ) == -1, "Error setting new flag values.");                    
                </Code>
        </Test>
         <Test Name="SetEOFBLOCKSFlag" FaultSimulationReady="true">              
                <Description>Try to set EXT2_EOFBLOCKS_FL flag.</Description>
                <Dir count="1"/>
                <Code>                 
                       int set_flags = EXT4_EXTENTS_FL | 0x00400000; //EXT4_EOFBLOCKS_FLL                     
                       ioctl(DirDs[0], EXT4_IOC_SETFLAGS, &set_flags); //ext4 doesn't support this flag                    
                </Code>
        </Test>
        <Test Name="ClearExtentsFlags">
                <Description>Try to clear the Extentes flag which is not allowed to be cleared.</Description>
                <File count="1"/>
                <Code>
                        // Backup the old values just in case
                        int old_flags;
                        Fail ( ioctl(FDs[0], EXT4_IOC_GETFLAGS, &old_flags ) == -1, "Error backing up old values.");
                        if(!(old_flags && EXT4_EXTENTS_FL))
                        {
                                Error("Extent flag not supported",Unsupported);
                        }
                        int non_permitted_flags = old_flags & ~EXT4_EXTENTS_FL; // We may NOT clear the extents flag... but we shall try!
                        
                        // Try to set the non-permitted flag
                        Fail( ioctl(FDs[0], EXT4_IOC_SETFLAGS, &non_permitted_flags ) == 0, "It was permitted to set non-permitted flag!.");
                                                        
                </Code>
        </Test>
        <Test Name="SetFlagsNotOwner">
                <Description>Try to perform a special operation not being file owner.</Description>
                <File count="1"/>
                <Code>
                        int flags = EXT4_EXTENTS_FL;                    
                        
                        ENoAccessTest(ioctl(FDs[0], EXT4_IOC_SETFLAGS, &flags ), -1);                   
                </Code>
        </Test>
        <Test Name="SetVersionGetVersion" FaultSimulationReady="true">
                <Description>Get and set version.</Description>
                <File count="1"/>
                <Code>
                        int set_version = 10; 
                        int get_version = 0;
                        
                        // Backup the old version just in case
                        int old_version;
                        Fail ( ioctl(FDs[0], EXT4_IOC_GETVERSION, &old_version) == -1, "Error backing up old version.");
                        
                        // Set our testing version value
                        Fail ( ioctl(FDs[0], EXT4_IOC_SETVERSION, &set_version) == -1, "Error setting new version values.");
                        
                        // Get the version back
                        Fail ( ioctl(FDs[0], EXT4_IOC_GETVERSION, &get_version) == -1, "Error getting version value back.");
                        
                        // Restore the original version
                        Fail ( ioctl(FDs[0], EXT4_IOC_SETVERSION, &old_version) == -1, "Error restoring old version value.");
                        
                        // Compare them
                        Check ( get_version != set_version, "Set and Get version mismatch");
                </Code>
        </Test>
        <!-- This commang is removed in newer kernels... -->
        <!--Test Name="WaitForReadonly" FaultSimulationReady="true" Shallow="true">

                <Description>Wait for read only.</Description>
                <File count="1"/>
                <Code>
#if  LINUX_VERSION_CODE > KERNEL_VERSION(3,1,0)
                Unsupp("Wait for read only operation is unsupported in Linux 3.1+ versions.");
#else
                        if ( ioctl(FDs[0], EXT4_IOC_WAIT_FOR_READONLY, NULL) == -1 )
                        {
                                if ( errno == ENOTTY )
                                {
                                        Error("EXT4_IOC_WAIT_FOR_READONLY is not supported.", Unsupported);
                                }
                                else
                                {
                                        Error("Error waiting for readonly.", Fail);
                                }
                        }
#endif
                </Code>         
        </Test-->
        <Test Name="GroupExtend" FaultSimulationReady="true">
        <Dangerous check="stability" fs="ext4"/>
                <Description>Group extend.</Description>
                <Header>            
                          Skip ( !PartitionManager::NoOptionsEnabled(), "Works only with no mount options." );

                </Header>
                <Code>
                        int res;
                        ext4_super_block sb;
                        Unres ( chdir("/") == -1, "Cannot change directory." );
                        res = PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem, true, true);
                        if( res!= PS_Success )
                        {
                                if( res == PS_Fatal )
                                {
                                        Error("Device too small.");
                                        Return(Unresolved);
                                }                                               
                                Error("Partition mount or umount failed");
                                Return(Unresolved);     
                        }                       
                        Unres( !PartitionManager::GetSuperBlock(&sb, sizeof(sb)), "Cannot read superblock" );
                        int BlockSize = (1 << (sb.s_log_block_size+10));
                        Unres(!BlockSize, "Block size is zero");
                        Unres ( chdir(MountPoint) == -1, "Cannot change directory." );
                        File file("GroupExtendfile");
                        
                        ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_EXTEND, 0);//covering code
                        int NewPartitionSizeInBlocks = PartitionManager::GetDeviceSize(DeviceName)/BlockSize - 50000;
                        Fail(ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_EXTEND, &NewPartitionSizeInBlocks) == -1,
                            "Error during online resize. ");
                </Code>
                <Footer>
                        if( PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem)!= PS_Success )
                        {
                                Error("Restoring Partition failed!");
                                Return(Fatal);
                        }
                </Footer>
        </Test>
        <Test Name="GroupExtendFail" FaultSimulationReady="true" Shallow="true">
                <Description>Group extend.</Description>
				<Header>            
					  	Skip ( !PartitionManager::NoOptionsEnabled(), "Works only with no mount options." );

				</Header>
                <Code>
                        int res;     
                        Unres ( chdir("/") == -1, "Cannot change directory." );
                        res = PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem, true, true);
                        if( res!= PS_Success )
                        {
                                if( res == PS_Fatal )
                                {
                                        Error("Device too small.");
                                        Return(Unresolved);
                                }                                               
                                Error("Partition mount or umount failed");
                                Return(Unresolved);     
                        }        
                        ext4_super_block sb;
						Unres( !PartitionManager::ReleasePartition(MountPoint), "Cannot unmount.");
						Unres(!PartitionManager::GetSuperBlock(&sb,sizeof(sb)),"Cannot read superblock.");
						sb.s_state = EXT4_ERROR_FS;
						int BlockSize = (1 << (sb.s_log_block_size+10));
                        Unres(!BlockSize, "Block size is zero");
						Unres(!PartitionManager::SetSuperBlock(&sb,sizeof(sb)),"Cannot write superblock.");
						Unres(!PartitionManager::Mount(DeviceName, MountPoint, FileSystem, "", 0), "Mount failed.");                       
                        Unres ( chdir(MountPoint) == -1, "Cannot change directory." );
                        File file("GroupExtendfile");
                   
                        int NewPartitionSizeInBlocks = PartitionManager::GetDeviceSize(DeviceName)/BlockSize - 50000;
                        ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_EXTEND, &NewPartitionSizeInBlocks);//will fail
                </Code>
                <Footer>
                        if( PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem)!= PS_Success )
                        {
                                Error("Restoring Partition failed!");
                                Return(Fatal);
                        }
                </Footer>
        </Test>
         
        <Test Name="ResizeFS" FaultSimulationReady="true" Shallow="true">
                <Requires KernelVersion="3.3.0" />
                <Description>Resize FS.</Description>
                <Header>            
                           Skip ( !PartitionManager::NoOptionsEnabled(), "Works only with no mount options." );

                </Header>
                <Code>  
                        int res;
                        ext4_super_block sb;
                        Unres ( chdir("/") == -1, "Cannot change directory." );
                        res = PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem, true, true);
                        if( res!= PS_Success )
                        {
                                if( res == PS_Fatal )
                                {
                                        Error("Device too small.");
                                        Return(Unresolved);
                                }                                               
                                Error("Partition mount or umount failed");
                                Return(Unresolved);     
                        }                       
                        
                        Unres ( chdir(MountPoint) == -1, "Cannot change directory." );
                        File file("ResizeFSfile");

                        uint64_t DeviceSize;
                        struct stat st;
                        Unres ( stat(DeviceName, &st) == -1, "Cannot get file stats.");
                                
                        if (S_ISREG(st.st_mode))
                        {
                                DeviceSize = st.st_size;
                        }
                        else
                        {
                                int fd = open(DeviceName, O_RDONLY);
                                Unres (fd == -1, "Cannot open partition");
                                
                                Unres ( ioctl( fd, BLKGETSIZE64, &DeviceSize ) == -1, "Cannot get partition size.");

                                close(fd);
                        }
                        Unres( !PartitionManager::GetSuperBlock(&sb, sizeof(sb)), "Cannot read superblock" );
                        int BlockSize = (1 << (sb.s_log_block_size+10));
                        Unres(!BlockSize, "Block size is zero");
                        __u64 BlockCount = DeviceSize / BlockSize;
                        Fail(ioctl(file.GetFileDescriptor(), EXT4_IOC_RESIZE_FS, &BlockCount) == -1, "Resize FS failed");
                </Code>
                <Footer>
                        if( PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem)!= PS_Success )
                        {
                                Error("Restoring Partition failed!");
                                Return(Fatal);
                        }
                </Footer>
        </Test>
         <Test Name="GroupAddDebug" FaultSimulationReady="true" Shallow="true">
                <Description>Group add.</Description>
                 <Header>            
                      	Skip ( !PartitionManager::NoOptionsEnabled(), "Works only with no mount options." );

                </Header>
                <Code>
                        int res;
                        ext4_super_block sb;
                        Unres ( chdir("/") == -1, "Cannot change directory." );
                        res = PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem, true, true);
                        if( res!= PS_Success )
                        {
                                if( res == PS_Fatal )
                                {
                                        Error("Device too small.");
                                        Return(Unresolved);
                                }                                               
                                Error("Partition mount or umount failed");
                                Return(Unresolved);     
                        }                       
						Unres( !PartitionManager::ReleasePartition(MountPoint), "Cannot unmount.");
						Unres(!PartitionManager::GetSuperBlock(&sb,sizeof(sb)),"Cannot read superblock.");
						sb.s_default_mount_opts |= EXT4_DEFM_DEBUG;
						int BlockSize = (1 << (sb.s_log_block_size+10));
                        Unres(!BlockSize, "Block size is zero");
						Unres(!PartitionManager::SetSuperBlock(&sb,sizeof(sb)),"Cannot write superblock.");
						Unres(!PartitionManager::Mount(DeviceName, MountPoint, FileSystem, "", 0), "Mount failed.");   
                        Unres ( chdir(MountPoint) == -1, "Cannot change directory." );
                        File file("GroupAddfile");
                        
                        
                        // NEED TO CONSIDER ALSO THE s_blocks_count_hi, in case of BIG file systems.
                        
                        int blockCount = ((sb.s_blocks_count_lo /  sb.s_blocks_per_group) + 1) * sb.s_blocks_per_group;
                        Unres(ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_EXTEND, &blockCount) == -1, "Cannot extend file system.");
                        
                        
                
                        // the modulo of devision of s_blocks_count on s_blocks_per_group may be not be an integer, so we are rounding it to up. 
                        blockCount = sb.s_blocks_count_lo - sb.s_first_data_block + sb.s_blocks_per_group - 1;
                        
                  #ifndef COMPAT
                        ext4_new_group_input input;
                        
                  #else
                        compat_ext4_new_group_input input;
                        
                  #endif
						memset(&input, 0, sizeof(input));
                        input.group = blockCount / sb.s_blocks_per_group ;
                        input.blocks_count = 32768;
                        
                        //these numbers must be bigger than blocks_count
                        input.block_bitmap = blockCount + 1;
                        input.inode_bitmap = blockCount + 2;
                        input.inode_table = blockCount + 3;
                        
                        Check(ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_ADD, &input) == -1, "Error adding Group");
                        
                </Code>
                <Footer>
						if( PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem)!= PS_Success )
						{
								Error("Restoring Partition failed!");
								Return(Fatal);
						}
                </Footer>
        </Test>
        <Test Name="GroupAdd" FaultSimulationReady="true" Shallow="true">
        <Dangerous check="stability" fs="ext4"/>
                <Description>Group add.</Description>
                 <Header>            
                          Skip ( !PartitionManager::NoOptionsEnabled(), "Works only with no mount options." );

                </Header>
                <Code>
                        int res;
                        ext4_super_block sb;
                        Unres ( chdir("/") == -1, "Cannot change directory." );
                        res = PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem, true, true);
                        if( res!= PS_Success )
                        {
                                if( res == PS_Fatal )
                                {
                                        Error("Device too small.");
                                        Return(Unresolved);
                                }                                               
                                Error("Partition mount or umount failed");
                                Return(Unresolved);     
                        }                       
                        Unres( !PartitionManager::GetSuperBlock(&sb, sizeof(sb)), "Cannot read superblock" );
                        int BlockSize = (1 << (sb.s_log_block_size+10));
                        Unres(!BlockSize, "Block size is zero");
                        Unres ( chdir(MountPoint) == -1, "Cannot change directory." );
                        File file("GroupAddfile");
                        
                        
                        // NEED TO CONSIDER ALSO THE s_blocks_count_hi, in case of BIG file systems.
                        
                        int blockCount = ((sb.s_blocks_count_lo /  sb.s_blocks_per_group) + 1) * sb.s_blocks_per_group;
                        Unres(ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_EXTEND, &blockCount) == -1, "Cannot extend file system.");
                        
                        
                
                        // the modulo of devision of s_blocks_count on s_blocks_per_group may be not be an integer, so we are rounding it to up. 
                        blockCount = sb.s_blocks_count_lo - sb.s_first_data_block + sb.s_blocks_per_group - 1;
                        
                  #ifndef COMPAT
                        ext4_new_group_input input;
                        
                  #else
                        compat_ext4_new_group_input input;
                        
                  #endif
                        memset(&input, 0, sizeof(input));
                        input.group = blockCount / sb.s_blocks_per_group ;
                        input.blocks_count = 32768;
                        
                        //these numbers must be bigger than blocks_count
                        input.block_bitmap = blockCount + 1;
                        input.inode_bitmap = blockCount + 2;
                        input.inode_table = blockCount + 3;
                        
                        Fail(ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_ADD, &input) == -1, "Error adding Group");
                        
                </Code>
                <Footer>
                        if( PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem)!= PS_Success )
                        {
                                Error("Restoring Partition failed!");
                                Return(Fatal);
                        }
                </Footer>
        </Test>
        
          <Test Name="GroupAdd1" FaultSimulationReady="true" Shallow="true">
                <Description>Group add.</Description>
                 <Header>            
                          Skip ( !PartitionManager::NoOptionsEnabled(), "Works only with no mount options." );

                </Header>
                <Code>
                        int res;
                        ext4_super_block sb;
                        Unres ( chdir("/") == -1, "Cannot change directory." );
                        res = PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem, true, true);
                        if( res!= PS_Success )
                        {
                                if( res == PS_Fatal )
                                {
                                        Error("Device too small.");
                                        Return(Unresolved);
                                }                                               
                                Error("Partition mount or umount failed");
                                Return(Unresolved);     
                        }                       
                        Unres( !PartitionManager::GetSuperBlock(&sb, sizeof(sb)), "Cannot read superblock" );
                        int BlockSize = (1 << (sb.s_log_block_size+10));
                        Unres(!BlockSize, "Block size is zero");
                        Unres ( chdir(MountPoint) == -1, "Cannot change directory." );
                        File file("GroupAddfile1");
                        
                        
                        // NEED TO CONSIDER ALSO THE s_blocks_count_hi, in case of BIG file systems.
                        
                        int blockCount = ((sb.s_blocks_count_lo /  sb.s_blocks_per_group) + 1) * sb.s_blocks_per_group;
                        Unres(ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_EXTEND, &blockCount) == -1, "Cannot extend file system.");
                        
                        
                
                        // the modulo of devision of s_blocks_count on s_blocks_per_group may be not be an integer, so we are rounding it to up. 
                        blockCount = sb.s_blocks_count_lo - sb.s_first_data_block + sb.s_blocks_per_group - 1;
                        
                  #ifndef COMPAT
                        ext4_new_group_input input;
                        
                  #else
                        compat_ext4_new_group_input input;
                        
                  #endif
                  
                    // we are covering error handling cases, so we don't wrap iostl-s in Fail macros.
                        memset(&input, 0, sizeof(input));
                        ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_ADD, &input);
                        input.group = blockCount / sb.s_blocks_per_group ;
                        ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_ADD, &input);
                        input.reserved_blocks = blockCount + 1;
                        ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_ADD, &input);                   
                        
                        memset(&input, 0, sizeof(input));   
                        input.group = blockCount / sb.s_blocks_per_group ;                     
                        input.blocks_count = 32768;
                        ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_ADD, &input);
                        input.block_bitmap = blockCount + 1;
                        ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_ADD, &input);
                        input.inode_bitmap = blockCount + 2;
                        ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_ADD, &input);
                        input.inode_table = blockCount + 3;
                        ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_ADD, &input);
                       
                </Code>
                <Footer>
                        if( PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem)!= PS_Success )
                        {
                                Error("Restoring Partition failed!");
                                Return(Fatal);
                        }
                </Footer>
        </Test>
     
        <Test Name="GroupAdd2" FaultSimulationReady="true" Shallow="true">
            <Description>Group add.</Description>
             <Header>            
                    Skip ( !PartitionManager::NoOptionsEnabled(), "Works only with no mount options." );

            </Header>
            <Code>
                    int res;
                    ext4_super_block sb;
                    Unres ( chdir("/") == -1, "Cannot change directory." );
                    res = PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem, true, true);
                    if( res!= PS_Success )
                    {
                            if( res == PS_Fatal )
                            {
                                    Error("Device too small.");
                                    Return(Unresolved);
                            }                                               
                            Error("Partition mount or umount failed");
                            Return(Unresolved);     
                    }                       
                    Unres( !PartitionManager::GetSuperBlock(&sb, sizeof(sb)), "Cannot read superblock" );
                    int BlockSize = (1 << (sb.s_log_block_size+10));
                    Unres(!BlockSize, "Block size is zero");
                    Unres ( chdir(MountPoint) == -1, "Cannot change directory." );
                    File file("GroupAddfile1");
                    
                    
                    // NEED TO CONSIDER ALSO THE s_blocks_count_hi, in case of BIG file systems.
                    
                    int blockCount = ((sb.s_blocks_count_lo /  sb.s_blocks_per_group) + 1) * sb.s_blocks_per_group;
                    Unres(ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_EXTEND, &blockCount) == -1, "Cannot extend file system.");
                    
                    
            
                    // the modulo of devision of s_blocks_count on s_blocks_per_group may be not be an integer, so we are rounding it to up. 
                    blockCount = sb.s_blocks_count_lo - sb.s_first_data_block + sb.s_blocks_per_group - 1;
                    
              #ifndef COMPAT
                    ext4_new_group_input input;
                    
              #else
                    compat_ext4_new_group_input input;
                    
              #endif
              
                // we are covering error handling cases, so we don't wrap iostl-s in Fail macros.
                    
                    memset(&input, 0, sizeof(input));
                    input.group = blockCount / sb.s_blocks_per_group ;
                    input.blocks_count = 32768;
                    input.block_bitmap = blockCount + 2;
                    input.inode_bitmap = blockCount + 2;
                    input.inode_table = blockCount + 3;
                    ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_ADD, &input);
                    
                    memset(&input, 0, sizeof(input));
                    input.group = blockCount / sb.s_blocks_per_group ;
                    input.blocks_count = 32768;
                    input.block_bitmap = blockCount + 10;
                    input.inode_bitmap = blockCount + 20;
                    input.inode_table = blockCount + 3;
                    ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_ADD, &input);
                
                    memset(&input, 0, sizeof(input));
                    input.group = blockCount / sb.s_blocks_per_group ;
                    input.blocks_count = 32768;
                    input.block_bitmap = blockCount + 1;
                    input.inode_bitmap = blockCount + 20;
                    input.inode_table = blockCount + 3;
                    ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_ADD, &input);
                   
            </Code>
            <Footer>
                    if( PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem)!= PS_Success )
                    {
                            Error("Restoring Partition failed!");
                            Return(Fatal);
                    }
            </Footer>
    </Test>

        <Test Name="Migrate" FaultSimulationReady="true" Shallow="true">
				<Dangerous check="stability" />
                <Description>Migrate an Ext3 partition to Ext4</Description>
                <Header>
                    
                        int _file = -1;
                    
                        // Temporary solution. Should be removed as soon as the logic of test execution is changed.             
                          Skip ( !PartitionManager::NoOptionsEnabled(), "Works only with no mount options." );

                              
                        #ifdef    COMPAT
                        Unsupp("Not supported in COMPAT mode.");
                        #endif    
                        
                        Unres ( !PartitionManager::ReleasePartition(MountPoint) , "Unmount failed!");
                                    
                </Header>
                <Code>                                 
                        UnixCommand mkfs("mkfs.ext3");
                        vector<string> args;
                        args.push_back(DeviceName);
                        ProcessResult * res;
                        res = mkfs.Execute(args);
                        Unres ( res == NULL || res->GetStatus() != Success, "Cannot create ext3 filesystem on device " + (string)DeviceName);
                
                        UnixCommand tunefs("tune2fs");
                        args.erase(args.begin(),args.end());
                        args.push_back("-O");
                        args.push_back("extents");
                        args.push_back(DeviceName);
                        
                        res = tunefs.Execute(args);
                        Unres ( res == NULL || res->GetStatus() != Success, "Cannot tune ext3 filesystem on device " + (string)DeviceName);
                        
                        delete res;
                        Unres ( mount( DeviceName, MountPoint, "ext4", 0, 0) == -1, "Cannot mount ext3 FS " + (string)DeviceName + " to " + (string)MountPoint);
                        
                        Unres ( chdir(MountPoint) != 0,"Cannot change current dir to " );

                        Unres( (_file = open(MountPoint, O_DIRECTORY | O_RDONLY)) == -1, "Cannot open dir");
                        
                        //Files
                        // 1024*100 files with 1 byte written occupy <= 2GB
                        int filesNum = 0;
                        if (PartitionManager:: GetDeviceSize(DeviceName) >= 2147483648)
                        {
                            filesNum = 102400;
                        }
                        const int FILES_NUM = filesNum;
                        int fds[FILES_NUM];
                        string filePaths[FILES_NUM];
                        
                        for(int i = 0; i < FILES_NUM; i++)
                        {
                            stringstream sstr;
                            sstr << i;
                            filePaths[i] = MountPoint + string("/ext4_migrate_file") + sstr.str();
                        }
                         
                        for (int i = 0; i < FILES_NUM; i++)
                        {
                            Unres( (fds[i] = open(filePaths[i].c_str(), O_CREAT | O_LARGEFILE | O_RDWR, S_IRWXU)) == -1, "failed to open/create file");
                            Unres(write(fds[i], "a", 1) == -1, "Failed to write to file");
                            close(fds[i]);
                        }                       
                        Fail ( ioctl(_file, EXT4_IOC_MIGRATE, 0) == -1,"Error migrating!" );
                        
                </Code>
                <Footer>
                        if (_file != -1)
                                close(_file);
                        if( PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem, true)!= PS_Success )
                        {
                                Error("Restore failed!");
                                _exit(Fatal);
                        }
                </Footer>
        </Test>
        <Test Name="MigrateFile" FaultSimulationReady="true" Shallow="true">
            <Dangerous check="stability"/>
                <Description>Migrate a large Ext3 file to Ext4</Description>
                <Header>
                        int fd = -1;
                        char FilePath[] = "Migrate_file";            
                        // Temporary solution. Should be removed as soon as the logic of test execution is changed.             
                          Skip ( !PartitionManager::NoOptionsEnabled(), "Works only with no mount options." );                          
                        #ifdef    COMPAT
                        Unsupp("Not supported in COMPAT mode.");
                        #endif                                   
                </Header>
                <Code>
                        char *WriteBuf = new char[64000*4096];
                        Unres ( !PartitionManager::ReleasePartition(MountPoint) , "Unmount failed!"); 
                        UnixCommand mkfs("mkfs.ext3");
                        vector<string> args;
                        args.push_back(DeviceName);
                        ProcessResult * res;
                        res = mkfs.Execute(args);
                        Unres ( res == NULL || res->GetStatus() != Success, "Cannot create ext3 filesystem on device " + (string)DeviceName);
                        Unres ( mount( DeviceName, MountPoint, "ext3", 0, 0) == -1, "Cannot mount ext3 FS " + (string)DeviceName + " to " + (string)MountPoint);
                         Unres ( chdir(MountPoint) != 0,"Cannot change current dir to " );
                        
                        fd = open(FilePath,O_RDWR | O_CREAT | O_EXCL | O_LARGEFILE, S_IRUSR | S_IWUSR);    
                        Unres(fd == -1, "Cannot create file.");
                        
                        // Check if it is possible to create file > 4GB; 
                        // 4819255296 = 4*1024*1024*1024 + 2*64000*4096 bytes ~ 4596 MB
                        if(PartitionManager:: GetDeviceSize(DeviceName) >= 4819255296 )
                        {
                            char* WriteBuf_ = new char[1024*1024*1024]; // 1GB
                            
                            for(int i = 0; i < 4; i++)
                                Unres(write(fd, WriteBuf_,1024*1024*1024) == -1, "Cannot write 1GB.");
                            
                            delete WriteBuf_;
                        }
                        Unres(write(fd, WriteBuf,64000*4096) == -1, "Cannot write.");
                                
                        close(fd);
                        
                        Unres ( !PartitionManager::ReleasePartition(MountPoint) , "Unmount failed!"); 
                        UnixCommand tunefs("tune2fs");
                        args.erase(args.begin(),args.end());
                        args.push_back("-O");
                        args.push_back("extents");
                        args.push_back(DeviceName);
                        
                        res = tunefs.Execute(args);
                        Unres ( res == NULL || res->GetStatus() != Success, "Cannot tune ext3 filesystem on device " + (string)DeviceName);
                        
                        delete res;
                        Unres ( mount( DeviceName, MountPoint, "ext4", 0, 0) == -1, "Cannot mount ext3 FS " + (string)DeviceName + " to " + (string)MountPoint);
                         
                        Unres ( chdir(MountPoint) != 0,"Cannot change current dir to " );
                        
                        Unres( (fd = open(FilePath, O_LARGEFILE, O_RDONLY)) == -1, "Cannot open file");
                        
                        // No meaning in Fail. It just brings to lots of skippings of the test.
                        Check ( ioctl(fd, EXT4_IOC_MIGRATE, 0) == -1,"Error migrating!" );
                        
                </Code>
                <Footer>       
                        unlink(FilePath);
                        close(fd);
                        if( PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem, true)!= PS_Success )
                        {
                                Error("Restore failed!");
                                _exit(Fatal);
                        }
                </Footer>
        </Test>
        <Test Name="MigrateFileWithXattr1" FaultSimulationReady="true" Shallow="true">
				<Dangerous check="stability" />
                <Description>Migrate an Ext3 file with extended attributes to Ext4</Description>
                <Header>
                        int fd = -1;
                        char FilePath[] = "Migrate_file";            
                        // Temporary solution. Should be removed as soon as the logic of test execution is changed.             
                          Skip ( !PartitionManager::NoOptionsEnabled(), "Works only with no mount options." );                          
                        #ifdef    COMPAT
                        Unsupp("Not supported in COMPAT mode.");
                        #endif                                   
                </Header>
                <Code>
                        char *WriteBuf = new char[4096];  
                        Unres ( !PartitionManager::ReleasePartition(MountPoint) , "Unmount failed!"); 
                        UnixCommand mkfs("mkfs.ext3");
                        vector<string> args;
                        args.push_back(DeviceName);
                        ProcessResult * res;
                        res = mkfs.Execute(args);
                        Unres ( res == NULL || res->GetStatus() != Success, "Cannot create ext3 filesystem on device " + (string)DeviceName);
                        Unres ( mount( DeviceName, MountPoint, "ext3", 0, 0) == -1, "Cannot mount ext3 FS " + (string)DeviceName + " to " + (string)MountPoint);
                         Unres ( chdir(MountPoint) != 0,"Cannot change current dir to " );
                        
                        fd = open(FilePath,O_RDWR | O_CREAT | O_EXCL | O_LARGEFILE, S_IRUSR | S_IWUSR);    
                        Unres(fd == -1, "Cannot create file.") ;
                        Unres(write(fd, WriteBuf,4096) == -1, "Cannot write.");        
                        const char * AttrName = "user.XattrSetGetTest";
                        const char * ValueSet = "asdf";        
                        const int ValueLen = strlen(ValueSet);
                        if ( removexattr(FilePath, AttrName) == -1 && errno != ENOATTR )
                        {
                            if ( errno == ENOTSUP )
                            {
                                Error("Xattrs are not supported.", Unsupported);
                            }
                            Unres(true, "Cannot remove xattr.");
                        }
                        Unres ( setxattr(FilePath, AttrName, ValueSet, ValueLen, XATTR_CREATE) == -1, "Cannot set xattr.");
                            
                        close(fd);
                        Unres ( !PartitionManager::ReleasePartition(MountPoint) , "Unmount failed!"); 
                        UnixCommand tunefs("tune2fs");
                        args.erase(args.begin(),args.end());
                        args.push_back("-O");
                        args.push_back("extents");
                        args.push_back(DeviceName);
                        
                        res = tunefs.Execute(args);
                        Unres ( res == NULL || res->GetStatus() != Success, "Cannot tune ext3 filesystem on device " + (string)DeviceName);
                        
                        delete res;
                        Unres ( mount( DeviceName, MountPoint, "ext4", 0, 0) == -1, "Cannot mount ext3 FS " + (string)DeviceName + " to " + (string)MountPoint);
                         
                        Unres ( chdir(MountPoint) != 0,"Cannot change current dir to " );
                        
                        Unres( (fd = open(FilePath, O_RDONLY)) == -1, "Cannot open file");
                        
                        // No meaning in Fail(). It just brings to lots of skipping os the test.
                        Check ( ioctl(fd, EXT4_IOC_MIGRATE, 0) == -1,"Error migrating!" );
                        
                </Code>
                <Footer>       
                        unlink(FilePath);
                        close(fd);
                        if( PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem, true)!= PS_Success )
                        {
                                Error("Restore failed!");
                                _exit(Fatal);
                        }
                </Footer>
        </Test>
        <Test Name="MigrateFileWithXattr2" FaultSimulationReady="true" Shallow="true">
				<Dangerous check="stability" />
                <Description>Migrate an Ext3 file with extended attributes to Ext4</Description>
                <Header>
                        int fd = -1;
                        char FilePath[] = "Migrate_file";            
                        // Temporary solution. Should be removed as soon as the logic of test execution is changed.             
                          Skip ( !PartitionManager::NoOptionsEnabled(), "Works only with no mount options." );                          
                        #ifdef    COMPAT
                        Unsupp("Not supported in COMPAT mode.");
                        #endif                                   
                </Header>
                <Code>
                        char *WriteBuf = new char[4096];  
                        Unres ( !PartitionManager::ReleasePartition(MountPoint) , "Unmount failed!"); 
                        UnixCommand mkfs("mkfs.ext3");
                        vector<string> args;
                        args.push_back(DeviceName);
                        ProcessResult * res;
                        res = mkfs.Execute(args);
                        Unres ( res == NULL || res->GetStatus() != Success, "Cannot create ext3 filesystem on device " + (string)DeviceName);
                        Unres ( mount( DeviceName, MountPoint, "ext3", 0, 0) == -1, "Cannot mount ext3 FS " + (string)DeviceName + " to " + (string)MountPoint);
                         Unres ( chdir(MountPoint) != 0,"Cannot change current dir to " );
                        
                        fd = open(FilePath,O_RDWR | O_CREAT | O_EXCL | O_LARGEFILE, S_IRUSR | S_IWUSR);    
                        Unres(fd == -1, "Cannot create file.") ;
                        Unres(write(fd, WriteBuf,4096) == -1, "Cannot write.");        
                        const char * AttrName = "user.XattrSetGetTest";
                        const char * ValueSet = new char[75];        
                        const int ValueLen = 75;
                        if ( removexattr(FilePath, AttrName) == -1 && errno != ENOATTR )
                        {
                            if ( errno == ENOTSUP )
                            {
                                Error("Xattrs are not supported.", Unsupported);
                            }
                            Unres(true, "Cannot remove xattr.");
                        }
                        Unres ( setxattr(FilePath, AttrName, ValueSet, ValueLen, XATTR_CREATE) == -1, "Cannot set xattr.");
                            
                        close(fd);
                        Unres ( !PartitionManager::ReleasePartition(MountPoint) , "Unmount failed!"); 
                        UnixCommand tunefs("tune2fs");
                        args.erase(args.begin(),args.end());
                        args.push_back("-O");
                        args.push_back("extents");
                        args.push_back(DeviceName);
                        
                        res = tunefs.Execute(args);
                        Unres ( res == NULL || res->GetStatus() != Success, "Cannot tune ext3 filesystem on device " + (string)DeviceName);
                        
                        delete res;
                        Unres ( mount( DeviceName, MountPoint, "ext4", 0, 0) == -1, "Cannot mount ext3 FS " + (string)DeviceName + " to " + (string)MountPoint);
                         
                        Unres ( chdir(MountPoint) != 0,"Cannot change current dir to " );
                        
                        Unres( (fd = open(FilePath, O_RDONLY)) == -1, "Cannot open file");
                        
                        // No meaning in the Fail(). It just brings to lots of skippings of the test.
                        Check ( ioctl(fd, EXT4_IOC_MIGRATE, 0) == -1,"Error migrating!" );
                        
                </Code>
                <Footer>       
                        unlink(FilePath);
                        close(fd);
                        if( PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem, true)!= PS_Success )
                        {
                                Error("Restore failed!");
                                _exit(Fatal);
                        }
                </Footer>
        </Test>
        <Test Name="AllocDABlocks" FaultSimulationReady="true" Shallow="true">
                <Description>Allocate delayed-allocation blocks.</Description>
                <File count="1"/>
                <Code>
                        #ifdef    COMPAT
                        Unsupp("Not supported in COMPAT mode.");
                        #else
                        Fail ( ioctl(FDs[0], EXT4_IOC_ALLOC_DA_BLKS, 0) == -1, "Error during delayed allocation of blocks.");   
                        #endif    
                </Code>
        </Test>
        <Test Name="Fitrim" FaultSimulationReady="true" Shallow="true">
                <Requires Defined="FITRIM" />
                <Description>FITRIM?</Description>
                <File count="1"/>
                <Code>
                        struct fstrim_range arg;
                        Fail ( ioctl(FDs[0], FITRIM, &arg) == -1 && errno != ENOTSUP, "Error FITRIM.");
                        if(errno == ENOTSUP)
                            Error("Fitrim not supported", Unsupported);
                </Code>
        </Test>
        <Test Name="CompatIoctlTests" Shallow="true">
                <Requires Defined="COMPAT" />
                <Description>EXT4_IOC32_GETRSVSZ and EXT4_IOC32_SETRSVSZ coverage tests</Description>
                <File count="1"/>
                <Code>
                        // This ioctl cases is not implemented, empty cases in compat_ioctl
                        char ptr; 
                        ioctl(FDs[0], EXT4_IOC32_GETRSVSZ, &ptr);
                        ioctl(FDs[0], EXT4_IOC32_SETRSVSZ, &ptr);
                </Code>
        </Test>
        <Test Name="Unsupported">
        <Description>Unsupported operation.</Description>
        <File count="1"/>
        <Code>
            Check(ioctl(FDs[0], -100, 0) != -1, "Function should fail but it did not.");
            Check(errno != ENOTTY && errno != EINVAL, "Function should return 'ENOTTY' or 'EINVAL' error but it did not.");
        </Code>
    </Test>
</TestSet>
