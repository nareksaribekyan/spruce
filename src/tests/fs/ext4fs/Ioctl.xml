<TestSet Name="Ioctl">
        <Requires>sys/ioctl.h</Requires>
        <Requires>linux/fs.h</Requires>
        <Requires>fcntl.h</Requires>
        <Requires>ext4.hpp</Requires>   
        <Requires>pwd.h</Requires>
        <Requires>linux/version.h</Requires>
        <Requires>inttypes.h</Requires>
        <Requires>ext4.hpp</Requires>
        <Requires>PartitionManager.hpp</Requires>
                
        <Test Name="SetFlagsGetFlags" FaultSimulationReady="true">              
                <Description>Try to set and get some flag values.</Description>
                <File count="1"/>
                <Code>
                        int set_flags = 0;
                        // Set 'EXT4_IMMUTABLE_FL' flag, assuming that created file is not immutable
                        if(PartitionManager:: IsOptionEnabled("-t ext2", true) || PartitionManager:: IsOptionEnabled("-t ext3", true))
                                set_flags = EXT4_IMMUTABLE_FL | EXT4_SECRM_FL;
                        else
                                set_flags = EXT4_EXTENTS_FL | EXT4_IMMUTABLE_FL | EXT4_SECRM_FL; // We may NOT clear the extents flag...
                                
                        int get_flags = 0;
                        
                        // Backup the old values just in case
                        int old_flags;  
                        Fail( ioctl(FDs[0], EXT4_IOC_GETFLAGS, &old_flags ) == -1 , "Error backing up old values.");
                        
                        // Set our testing flag values
                        Fail ( ioctl(FDs[0], EXT4_IOC_SETFLAGS, &set_flags ) == -1, "Error setting new flag values.");
                
                        // Get the flags back
                        Fail ( ioctl(FDs[0], EXT4_IOC_GETFLAGS, &get_flags ) == -1, "Error getting flag values back.");
                        
                        // Restore the original flags
                        Fail ( ioctl(FDs[0], EXT4_IOC_SETFLAGS, &old_flags ) == -1, "Error restoring old flag values.");
                        
                        // Compare them
                        Check ( get_flags != set_flags, "Set and Get flags mismatch");
                </Code>
        </Test>
		 <Test Name="SetAllFlags" FaultSimulationReady="true">              
                <Description>Try to set and get some flag values.</Description>
                <Dir count="1"/>
                <Code>
                  
                        int set_flags = EXT4_EXTENTS_FL | EXT4_IMMUTABLE_FL | EXT4_SECRM_FL | EXT4_SYNC_FL | EXT4_APPEND_FL | EXT4_NOATIME_FL | EXT4_DIRSYNC_FL;                     
                        Fail ( ioctl(DirDs[0], EXT4_IOC_SETFLAGS, &set_flags ) == -1, "Error setting new flag values.");
                
                       
                </Code>
        </Test>
        <Test Name="ClearExtentsFlags">
                <Description>Try to clear the Extentes flag which is not allowed to be cleared.</Description>
                <File count="1"/>
                <Code>
                        // Backup the old values just in case
                        int old_flags;
                        Fail ( ioctl(FDs[0], EXT4_IOC_GETFLAGS, &old_flags ) == -1, "Error backing up old values.");
                        if(!(old_flags && EXT4_EXTENTS_FL))
                        {
                                Error("Extent flag not supported",Unsupported);
                        }
                        int non_permitted_flags = old_flags & ~EXT4_EXTENTS_FL; // We may NOT clear the extents flag... but we shall try!
                        
                        // Try to set the non-permitted flag
                        Fail( ioctl(FDs[0], EXT4_IOC_SETFLAGS, &non_permitted_flags ) == 0, "It was permitted to set non-permitted flag!.");
                                                        
                </Code>
        </Test>
        <Test Name="SetFlagsNotOwner">
                <Description>Try to perform a special operation not being file owner.</Description>
                <File count="1"/>
                <Code>
                        int flags = EXT4_EXTENTS_FL;                    
                        
                        ENoAccessTest(ioctl(FDs[0], EXT4_IOC_SETFLAGS, &flags ), -1);                   
                </Code>
        </Test>
        <Test Name="SetVersionGetVersion" FaultSimulationReady="true">
                <Description>Get and set version.</Description>
                <File count="1"/>
                <Code>
                        int set_version = 10; 
                        int get_version = 0;
                        
                        // Backup the old version just in case
                        int old_version;
                        Fail ( ioctl(FDs[0], EXT4_IOC_GETVERSION, &old_version) == -1, "Error backing up old version.");
                        
                        // Set our testing version value
                        Fail ( ioctl(FDs[0], EXT4_IOC_SETVERSION, &set_version) == -1, "Error setting new version values.");
                        
                        // Get the version back
                        Fail ( ioctl(FDs[0], EXT4_IOC_GETVERSION, &get_version) == -1, "Error getting version value back.");
                        
                        // Restore the original version
                        Fail ( ioctl(FDs[0], EXT4_IOC_SETVERSION, &old_version) == -1, "Error restoring old version value.");
                        
                        // Compare them
                        Check ( get_version != set_version, "Set and Get version mismatch");
                </Code>
        </Test>
        <!-- This commang is removed in newer kernels... -->
        <!--Test Name="WaitForReadonly" FaultSimulationReady="true" Shallow="true">

                <Description>Wait for read only.</Description>
                <File count="1"/>
                <Code>
#if  LINUX_VERSION_CODE > KERNEL_VERSION(3,1,0)
                Unsupp("Wait for read only operation is unsupported in Linux 3.1+ versions.");
#else
                        if ( ioctl(FDs[0], EXT4_IOC_WAIT_FOR_READONLY, NULL) == -1 )
                        {
                                if ( errno == ENOTTY )
                                {
                                        Error("EXT4_IOC_WAIT_FOR_READONLY is not supported.", Unsupported);
                                }
                                else
                                {
                                        Error("Error waiting for readonly.", Fail);
                                }
                        }
#endif
                </Code>         
        </Test-->
        <Test Name="GroupExtend" FaultSimulationReady="true" Shallow="true">
                <Description>Group extend.</Description>
				<Header>            
					  	Skip ( !PartitionManager::NoOptionsEnabled(), "Works only with no mount options." );

				</Header>
                <Code>
                        int res;
                        ext4_super_block sb;
                        Unres ( chdir("/") == -1, "Cannot change directory." );
                        res = PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem, true, true);
                        if( res!= PS_Success )
                        {
                                if( res == PS_Fatal )
                                {
                                        Error("Device too small.");
                                        Return(Unresolved);
                                }                                               
                                Error("Partition mount or umount failed");
                                Return(Unresolved);     
                        }                       
                        Unres( !PartitionManager::GetSuperBlock(&sb, sizeof(sb)), "Cannot read superblock" );
                        int BlockSize = (1 << (sb.s_log_block_size+10));
                        Unres(!BlockSize, "Block size is zero");
                        Unres ( chdir(MountPoint) == -1, "Cannot change directory." );
                        File file("GroupExtendfile");
                        
                        ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_EXTEND, 0);//covering code
                        int NewPartitionSizeInBlocks = PartitionManager::GetDeviceSize(DeviceName)/BlockSize - 50000;
                        Fail(ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_EXTEND, &NewPartitionSizeInBlocks) == -1,
							"Error during online resize. ");
                </Code>
                <Footer>
                        if( PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem)!= PS_Success )
                        {
                                Error("Restoring Partition failed!");
                                Return(Fatal);
                        }
                </Footer>
        </Test>
        <Test Name="ResizeFS" FaultSimulationReady="true" Shallow="true">
                <Requires KernelVersion="3.3.0" />
                <Description>Resize FS.</Description>
				<Header>            
					   	Skip ( !PartitionManager::NoOptionsEnabled(), "Works only with no mount options." );

                </Header>
                <Code>  
                        int res;
                        ext4_super_block sb;
                        Unres ( chdir("/") == -1, "Cannot change directory." );
                        res = PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem, true, true);
                        if( res!= PS_Success )
                        {
                                if( res == PS_Fatal )
                                {
                                        Error("Device too small.");
                                        Return(Unresolved);
                                }                                               
                                Error("Partition mount or umount failed");
                                Return(Unresolved);     
                        }                       
                        
                        Unres ( chdir(MountPoint) == -1, "Cannot change directory." );
                        File file("ResizeFSfile");

                        uint64_t DeviceSize;
                        struct stat st;
                        Unres ( stat(DeviceName, &st) == -1, "Cannot get file stats.");
                                
                        if (S_ISREG(st.st_mode))
                        {
                                DeviceSize = st.st_size;
                        }
                        else
                        {
                                int fd = open(DeviceName, O_RDONLY);
                                Unres (fd == -1, "Cannot open partition");
                                
                                Unres ( ioctl( fd, BLKGETSIZE64, &DeviceSize ) == -1, "Cannot get partition size.");

                                close(fd);
                        }
                        Unres( !PartitionManager::GetSuperBlock(&sb, sizeof(sb)), "Cannot read superblock" );
                        int BlockSize = (1 << (sb.s_log_block_size+10));
                        Unres(!BlockSize, "Block size is zero");
                        __u64 BlockCount = DeviceSize / BlockSize;
                        Fail(ioctl(file.GetFileDescriptor(), EXT4_IOC_RESIZE_FS, &BlockCount) == -1, "Resize FS failed");
                </Code>
                <Footer>
                        if( PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem)!= PS_Success )
                        {
                                Error("Restoring Partition failed!");
                                Return(Fatal);
                        }
                </Footer>
        </Test>
        <Test Name="MoveExtent" FaultSimulationReady="true" Shallow="true">
                <Description>Move extent.</Description>
                <File count="2"/>
                <Code>
                        Unres (unlink(FilePaths[0].c_str()) == -1, "Cannot unlink the donor file.");
                        
                        Unres ( fallocate(FDs[0], 0, 0, 32000*2*4096), "Cannot allocate space for donor file.");
                        
                        Unres ( fallocate(FDs[1], 0, 0, 32000*2*4096), "Cannot allocate space for original file.");
                        
                        //unsigned int BlockCount = 1;
                        
                        struct move_extent me;
                        memset(&me, 0, sizeof(me));
                        me.donor_fd = FDs[0];
                        me.orig_start = 0;
                        me.donor_start = 0;
                        me.len = 2;
                        me.moved_len = 0;
                        
                        
                        Fail ( ioctl(FDs[1], EXT4_IOC_MOVE_EXT, &me) == -1 , "Error moving extent.");
                        
                </Code>
        </Test>
        <Test Name="GroupAdd" FaultSimulationReady="true" Shallow="true">
                <Description>Group add.</Description>
                 <Header>            
                      	Skip ( !PartitionManager::NoOptionsEnabled(), "Works only with no mount options." );

                </Header>
                <Code>
                        int res;
                        ext4_super_block sb;
                        Unres ( chdir("/") == -1, "Cannot change directory." );
                        res = PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem, true, true);
                        if( res!= PS_Success )
                        {
                                if( res == PS_Fatal )
                                {
                                        Error("Device too small.");
                                        Return(Unresolved);
                                }                                               
                                Error("Partition mount or umount failed");
                                Return(Unresolved);     
                        }                       
                        Unres( !PartitionManager::GetSuperBlock(&sb, sizeof(sb)), "Cannot read superblock" );
                        int BlockSize = (1 << (sb.s_log_block_size+10));
                        Unres(!BlockSize, "Block size is zero");
                        Unres ( chdir(MountPoint) == -1, "Cannot change directory." );
                        File file("GroupAddfile");
                        
                        
                        // NEED TO CONSIDER ALSO THE s_blocks_count_hi, in case of BIG file systems.
                        
                        int blockCount = ((sb.s_blocks_count_lo /  sb.s_blocks_per_group) + 1) * sb.s_blocks_per_group;
                        Unres(ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_EXTEND, &blockCount) == -1, "Cannot extend file system.");
                        
                        
                
                        // the modulo of devision of s_blocks_count on s_blocks_per_group may be not be an integer, so we are rounding it to up. 
                        blockCount = sb.s_blocks_count_lo - sb.s_first_data_block + sb.s_blocks_per_group - 1;
                        
                  #ifndef COMPAT
                        ext4_new_group_input input;
                        
                  #else
                        compat_ext4_new_group_input input;
                        
                  #endif
						memset(&input, 0, sizeof(input));
                        input.group = blockCount / sb.s_blocks_per_group ;
                        input.blocks_count = 32768;
                        
                        //these numbers must be bigger than blocks_count
                        input.block_bitmap = blockCount + 1;
                        input.inode_bitmap = blockCount + 2;
                        input.inode_table = blockCount + 3;
                        
                        Fail(ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_ADD, &input) == -1, "Error adding Group");
                        
                </Code>
                <Footer>
						if( PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem)!= PS_Success )
						{
								Error("Restoring Partition failed!");
								Return(Fatal);
						}
                </Footer>
        </Test>
        
          <Test Name="GroupAdd1" FaultSimulationReady="true" Shallow="true">
                <Description>Group add.</Description>
                 <Header>            
                      	Skip ( !PartitionManager::NoOptionsEnabled(), "Works only with no mount options." );

                </Header>
                <Code>
                        int res;
                        ext4_super_block sb;
                        Unres ( chdir("/") == -1, "Cannot change directory." );
                        res = PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem, true, true);
                        if( res!= PS_Success )
                        {
                                if( res == PS_Fatal )
                                {
                                        Error("Device too small.");
                                        Return(Unresolved);
                                }                                               
                                Error("Partition mount or umount failed");
                                Return(Unresolved);     
                        }                       
                        Unres( !PartitionManager::GetSuperBlock(&sb, sizeof(sb)), "Cannot read superblock" );
                        int BlockSize = (1 << (sb.s_log_block_size+10));
                        Unres(!BlockSize, "Block size is zero");
                        Unres ( chdir(MountPoint) == -1, "Cannot change directory." );
                        File file("GroupAddfile1");
                        
                        
                        // NEED TO CONSIDER ALSO THE s_blocks_count_hi, in case of BIG file systems.
                        
                        int blockCount = ((sb.s_blocks_count_lo /  sb.s_blocks_per_group) + 1) * sb.s_blocks_per_group;
                        Unres(ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_EXTEND, &blockCount) == -1, "Cannot extend file system.");
                        
                        
                
                        // the modulo of devision of s_blocks_count on s_blocks_per_group may be not be an integer, so we are rounding it to up. 
                        blockCount = sb.s_blocks_count_lo - sb.s_first_data_block + sb.s_blocks_per_group - 1;
                        
                  #ifndef COMPAT
                        ext4_new_group_input input;
                        
                  #else
                        compat_ext4_new_group_input input;
                        
                  #endif
                  
					// we are covering error handling cases, so we don't wrap iostl-s in Fail macros.
						memset(&input, 0, sizeof(input));
						ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_ADD, &input);
					    input.group = blockCount / sb.s_blocks_per_group ;
                        ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_ADD, &input);
                        input.reserved_blocks = blockCount + 1;
                        ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_ADD, &input);                   
                        
                        memset(&input, 0, sizeof(input));   
                        input.group = blockCount / sb.s_blocks_per_group ;                     
                        input.blocks_count = 32768;
                        ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_ADD, &input);
                        input.block_bitmap = blockCount + 1;
                        ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_ADD, &input);
                        input.inode_bitmap = blockCount + 2;
						ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_ADD, &input);
                        input.inode_table = blockCount + 3;
						ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_ADD, &input);
                       
                </Code>
                <Footer>
						if( PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem)!= PS_Success )
						{
								Error("Restoring Partition failed!");
								Return(Fatal);
						}
                </Footer>
        </Test>
     
		<Test Name="GroupAdd2" FaultSimulationReady="true" Shallow="true">
			<Description>Group add.</Description>
			 <Header>            
					Skip ( !PartitionManager::NoOptionsEnabled(), "Works only with no mount options." );

			</Header>
			<Code>
					int res;
					ext4_super_block sb;
					Unres ( chdir("/") == -1, "Cannot change directory." );
					res = PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem, true, true);
					if( res!= PS_Success )
					{
							if( res == PS_Fatal )
							{
									Error("Device too small.");
									Return(Unresolved);
							}                                               
							Error("Partition mount or umount failed");
							Return(Unresolved);     
					}                       
					Unres( !PartitionManager::GetSuperBlock(&sb, sizeof(sb)), "Cannot read superblock" );
					int BlockSize = (1 << (sb.s_log_block_size+10));
					Unres(!BlockSize, "Block size is zero");
					Unres ( chdir(MountPoint) == -1, "Cannot change directory." );
					File file("GroupAddfile1");
					
					
					// NEED TO CONSIDER ALSO THE s_blocks_count_hi, in case of BIG file systems.
					
					int blockCount = ((sb.s_blocks_count_lo /  sb.s_blocks_per_group) + 1) * sb.s_blocks_per_group;
					Unres(ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_EXTEND, &blockCount) == -1, "Cannot extend file system.");
					
					
			
					// the modulo of devision of s_blocks_count on s_blocks_per_group may be not be an integer, so we are rounding it to up. 
					blockCount = sb.s_blocks_count_lo - sb.s_first_data_block + sb.s_blocks_per_group - 1;
					
			  #ifndef COMPAT
					ext4_new_group_input input;
					
			  #else
					compat_ext4_new_group_input input;
					
			  #endif
			  
				// we are covering error handling cases, so we don't wrap iostl-s in Fail macros.
					
					memset(&input, 0, sizeof(input));
					input.group = blockCount / sb.s_blocks_per_group ;
					input.blocks_count = 32768;
					input.block_bitmap = blockCount + 2;
					input.inode_bitmap = blockCount + 2;
					input.inode_table = blockCount + 3;
					ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_ADD, &input);
					
					memset(&input, 0, sizeof(input));
					input.group = blockCount / sb.s_blocks_per_group ;
					input.blocks_count = 32768;
					input.block_bitmap = blockCount + 10;
					input.inode_bitmap = blockCount + 20;
					input.inode_table = blockCount + 3;
					ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_ADD, &input);
				
					memset(&input, 0, sizeof(input));
					input.group = blockCount / sb.s_blocks_per_group ;
					input.blocks_count = 32768;
					input.block_bitmap = blockCount + 1;
					input.inode_bitmap = blockCount + 20;
					input.inode_table = blockCount + 3;
					ioctl(file.GetFileDescriptor(), EXT4_IOC_GROUP_ADD, &input);
				   
			</Code>
			<Footer>
					if( PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem)!= PS_Success )
					{
							Error("Restoring Partition failed!");
							Return(Fatal);
					}
			</Footer>
	</Test>

        <Test Name="Migrate" FaultSimulationReady="true" Shallow="true">
                <Description>Migrate an Ext3 partition to Ext4</Description>
                <Header>
					
						int _file = -1;
					
                        // Temporary solution. Should be removed as soon as the logic of test execution is changed.             
                      	Skip ( !PartitionManager::NoOptionsEnabled(), "Works only with no mount options." );

                              
                        #ifdef	COMPAT
						Unsupp("Not supported in COMPAT mode.");
						#endif	
                        
                        Unres ( !PartitionManager::ReleasePartition(MountPoint) , "Unmount failed!");
                                    
                </Header>
                <Code>
                                 
                        UnixCommand mkfs("mkfs.ext3");
                        vector<string> args;
                        args.push_back(DeviceName);
                        ProcessResult * res;
                        res = mkfs.Execute(args);
                        Unres ( res == NULL || res->GetStatus() != Success, "Cannot create ext3 filesystem on device " + (string)DeviceName);
                
                        UnixCommand tunefs("tune2fs");
                        args.erase(args.begin(),args.end());
                        args.push_back("-O");
                        args.push_back("extents");
                        args.push_back(DeviceName);
                        
                        res = tunefs.Execute(args);
                        Unres ( res == NULL || res->GetStatus() != Success, "Cannot tune ext3 filesystem on device " + (string)DeviceName);
                        
                        delete res;
                        Unres ( mount( DeviceName, MountPoint, "ext4", 0, 0) == -1, "Cannot mount ext3 FS " + (string)DeviceName + " to " + (string)MountPoint);
                        Unres ( chdir(MountPoint) != 0,"Cannot change current dir to " );

                        Unres( (_file = open(MountPoint, O_DIRECTORY | O_RDONLY)) == -1, "Cannot open dir");
                        
                        Fail ( ioctl(_file, EXT4_IOC_MIGRATE, 0) == -1,"Error migrating!" );
                        
                </Code>
                <Footer>
                        if (_file != -1)
                                close(_file);
                        if( PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem, true)!= PS_Success )
                        {
                                Error("Restore failed!");
                                _exit(Fatal);
                        }
                </Footer>
        </Test>
        <Test Name="AllocDABlocks" FaultSimulationReady="true" Shallow="true">
                <Description>Allocate delayed-allocation blocks.</Description>
                <File count="1"/>
                <Code>
						#ifdef	COMPAT
						Unsupp("Not supported in COMPAT mode.");
						#else
                        Fail ( ioctl(FDs[0], EXT4_IOC_ALLOC_DA_BLKS, 0) == -1, "Error during delayed allocation of blocks.");   
                        #endif	
                </Code>
        </Test>
        <Test Name="Fitrim" FaultSimulationReady="true" Shallow="true">
                <Requires Defined="FITRIM" />
                <Description>FITRIM?</Description>
                <File count="1"/>
                <Code>
                        struct fstrim_range arg;
                        Fail ( ioctl(FDs[0], FITRIM, &arg) == -1 && errno != ENOTSUP, "Error FITRIM.");
                        if(errno == ENOTSUP)
							Error("Fitrim not supported", Unsupported);
                </Code>
        </Test>
        <Test Name="CompatIoctlTests" Shallow="true">
                <Requires Defined="COMPAT" />
                <Description>EXT4_IOC32_GETRSVSZ and EXT4_IOC32_SETRSVSZ coverage tests</Description>
                <File count="1"/>
                <Code>
						// This ioctl cases is not implemented, empty cases in compat_ioctl
                        char ptr; 
                        ioctl(FDs[0], EXT4_IOC32_GETRSVSZ, &ptr);
                        ioctl(FDs[0], EXT4_IOC32_SETRSVSZ, &ptr);
                </Code>
        </Test>
        <Test Name="Unsupported">
        <Description>Unsupported operation.</Description>
        <File count="1"/>
        <Code>
            Check(ioctl(FDs[0], -100, 0) != -1, "Function should fail but it did not.");
            Check(errno != ENOTTY && errno != EINVAL, "Function should return 'ENOTTY' or 'EINVAL' error but it did not.");
        </Code>
    </Test>
</TestSet>
