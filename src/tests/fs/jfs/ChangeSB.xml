<!--    OverloadTests.xml
//      
//      Copyright (C) 2011, Institute for System Programming
//                          of the Russian Academy of Sciences (ISPRAS)
//      Author:
//			Nellie Danielyan <Nellie.92.d@gmail.com>
//
//      This program is free software; you can redistribute it and/or modify
//      it under the terms of the GNU General Public License as published by
//      the Free Software Foundation; either version 2 of the License, or
//      (at your option) any later version.
//      
//      This program is distributed in the hope that it will be useful,
//      but WITHOUT ANY WARRANTY; without even the implied warranty of
//      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//      GNU General Public License for more details.
//      
//      You should have received a copy of the GNU General Public License
//      along with this program; if not, write to the Free Software
//      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
//      MA 02110-1301, USA.
-->
<TestSet Name="ChangeSB">
	<StartUp>
		Skip(!PartitionManager::NoOptionsEnabled(),
		 "These tests should run only when no options are provided.");
	</StartUp>
	<Requires>dirent.h</Requires>	
	<Requires>jfs_filsys.h</Requires>
	<Requires>JFSCtl.hpp</Requires>	
	<Test Name="JFS_DIR_INDEX" FaultSimulationReady="true">
		<Description>Unset JFS_DIR_INDEX flag and read a directory.</Description>
		<Code>
			jfs_superblock sb;
			DIR *dir;
			Unres( !PartitionManager::ReleasePartition(MountPoint), "Cannot unmount.")
			Unres(!PartitionManager::GetSuperBlock(&sb,sizeof(sb)),"Cannot read superblock.");
			sb.s_flag &= ~JFS_DIR_INDEX;
			Unres(!PartitionManager::SetSuperBlock(&sb,sizeof(sb)),"Cannot write superblock.");
			Unres(!PartitionManager::Mount(DeviceName, MountPoint, FileSystem, ""), "Cannot mount.");
			Unres ( chdir(MountPoint) == -1, "Cannot change directory." );
			char buf[10];
			string dirname = "some_directory";
			
			mkdir(dirname.c_str(), 0777);
			chdir(dirname.c_str());
			for (int j = 0; j < 10000; ++j)
			{
				sprintf(buf, "%d",  j);
				string dirname = buf;
				mkdir(dirname.c_str(), 0777);
				close(open(("1" + dirname).c_str(), O_RDWR | O_CREAT));				
			}
			Unres ( chdir(MountPoint) == -1, "Cannot change directory." );
			
			dir = opendir(dirname.c_str());
			Unres(!dir, "Cannot open directory.");
			errno = 0;
			while(readdir(dir))
			{
				Fail(errno, "Cannot read directory.");			
			}
			closedir(dir);
		
		</Code>
	</Test>
	<Test Name="DirtyState" FaultSimulationReady="true">
		<Description>Set jfs superblock state dirty and try to mount.</Description>
		<Code>
			jfs_superblock sb;
			DIR *dir;
			Unres( !PartitionManager::ReleasePartition(MountPoint), "Cannot unmount.")
			Unres(!PartitionManager::GetSuperBlock(&sb,sizeof(sb)),"Cannot read superblock.");
			sb.s_state = FM_DIRTY;
			Unres(!PartitionManager::SetSuperBlock(&sb,sizeof(sb)),"Cannot set new superblock");
			PartitionManager::Mount(DeviceName, MountPoint, FileSystem, "");//will fail in this version of jfs, though it's not documented behaviour 

			Unres ( chdir(MountPoint) == -1, "Cannot change directory." );
	
		</Code>
	</Test>
	<Test Name="WrongBlockSize" FaultSimulationReady="true">
		<Description>Set wrong block size in jfs superblock and try to mount.</Description>
		<Code>
			jfs_superblock sb;
			DIR *dir;
			Unres( !PartitionManager::ReleasePartition(MountPoint), "Cannot unmount.")
			Unres(!PartitionManager::GetSuperBlock(&sb,sizeof(sb)),"Cannot read superblock.");
			sb.s_bsize = 1000;
			Unres(!PartitionManager::SetSuperBlock(&sb,sizeof(sb)),"Cannot set new superblock");
			PartitionManager::Mount(DeviceName, MountPoint, FileSystem, "");//will fail in this version of jfs, though it's not documented behaviour 
			Unres ( chdir(MountPoint) == -1, "Cannot change directory." );
	
		</Code>
	</Test>
	<Test Name="xtExtendFail">
		<Description>Brings to failure in xtExtend function.</Description>
		<Header>
			int fd = -1;
		</Header>
		<Code>
			const char * FilePath = "test";
			int fd = open(FilePath, O_RDWR | O_CREAT | O_EXCL | O_LARGEFILE, S_IRUSR | S_IWUSR);
			
			Unres(fd == -1, "Cannot create file.");
			
			Unres(write(fd, "asdf", 4) == -1, "Cannot write to file.");
			
			fsync(fd);
			close(fd);
			sync();
			
			JFSCtl jfs;
			int inode_num = jfs.GetInodeNum(FilePath);
			
			Unres(PartitionManager::ReleasePartition(MountPoint) == false, "Cannot release partition.");
			
			dinode * inode = jfs.GetInode(DeviceName, inode_num);
			Unres(inode == NULL, "Cannot get inode.");
			
			((xad*)inode->di_xtroot)[2].len = 0xFFFFFF;
			
			Unres(jfs.SetInode(DeviceName, inode_num, inode) == false, "Cannot set inode.");
			
			Unres(PartitionManager::Mount(DeviceName, MountPoint, FileSystem, "", 0) == false, "Cannot mount partition back.");
			
			Unres(chdir(MountPoint) == -1, "Cannot chdir to mount point.");
			
			fd = open(FilePath, O_RDWR | O_LARGEFILE, S_IRUSR | S_IWUSR);
			Unres(fd == -1, "Cannot open file.");
			
			char * buf = new char[5000];
			
			write(fd, buf, 5000);
			
			fsync(fd);
			close(fd);
			
			unlink(FilePath);
			
			sync();
		</Code>
		<Footer>
			close(fd);
		</Footer>
	</Test>
	
	<Test Name="xtGetPageFail">
		<Description>Brings to failure in XT_GETPAGE.</Description>
		<Header>
			int fd = -1;
		</Header>
		<Code>
			
			const char * FilePath = "StackOverflow_test";
			int fd = open(FilePath, O_RDWR | O_CREAT | O_EXCL | O_LARGEFILE, S_IRUSR | S_IWUSR);
			
			Unres(fd == -1, "Cannot create file.");
			Unres(write(fd, "asdf", 4) == -1, "Cannot write to file.");
			close(fd);
			sync();
			
			JFSCtl jfs;
			int inode_num = jfs.GetInodeNum(FilePath);
			
			Unres(PartitionManager::ReleasePartition(MountPoint) == false, "Cannot release partition.");
					
			dinode * inode = jfs.GetInode(DeviceName, inode_num);
			Unres(inode == NULL, "Cannot get inode.");
					
			xtpage_t * page = (xtpage_t*)&inode->di_xtroot;
			page->header.nextindex = 1;
			
			Unres(jfs.SetInode(DeviceName, inode_num, inode) == false, "Cannot set inode.");
			
			
			Unres(PartitionManager::Mount(DeviceName, MountPoint, FileSystem, "", 0) == false, "Cannot mount partition back.");
			Unres(chdir(MountPoint) == -1, "Cannot chdir to mount point.");
			unlink(FilePath);
			
			sync();
		</Code>
		<Footer>
			close(fd);
		</Footer>
	</Test>
	<Test Name="xtSearchFail">
		<Description>Brings to failure in xtSearch function due to stack overflow.</Description>
		<Header>
			int fd = -1;
		</Header>
		<Code>
			
			const char * FilePath = "xtSearch_test";
			int fd = open(FilePath, O_RDWR | O_CREAT | O_EXCL | O_LARGEFILE, S_IRUSR | S_IWUSR);
			
			Unres(fd == -1, "Cannot create file.");
			
			Unres(write(fd, "asdf", 4) == -1, "Cannot write to file.");
			
			close(fd);
			
			sync();
			
			Unres( OverflowStack(FilePath) == false, "Cannot prepare stack." );
			
			fd = open(FilePath, O_RDWR | O_LARGEFILE, S_IRUSR | S_IWUSR);
			Unres(fd == -1, "Cannot open file.");
			
			char * buf = new char[5000];
			
			Unres( lseek(fd, 10000, SEEK_SET) == -1, "Cannot seek." );
			
			Check( write(fd, buf, 10) == 0, "Write should fail but it did not.");
			
			close(fd);
		</Code>
		<Footer>
			close(fd);
		</Footer>
	</Test>
	<Test Name="xtTruncateFail" Dangerous="true">
		<Description>Brings to failure in xtTruncate function due to stack overflow.</Description>
		<Header>
			int fd = -1;
		</Header>
		<Code>
			Fatal( PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem, true) != PS_Success,"Mount failed" );
			
			Unres(chdir(MountPoint) == -1, "Cannot change directory back.");
			
			const char * FilePath = "xtTruncateFail_test";
			int fd = open(FilePath, O_RDWR | O_CREAT | O_LARGEFILE, S_IRUSR | S_IWUSR);
			
			Unres(fd == -1, "Cannot create file.");
			
			Unres(write(fd, "asdf", 4) == -1, "Cannot write to file.");
			
			close(fd);
			
			sync();
			
			Unres( OverflowStack(FilePath) == false, "Cannot prepare stack." );
			
			fd = open(FilePath, O_RDWR | O_LARGEFILE, S_IRUSR | S_IWUSR);
			Unres(fd == -1, "Cannot open file.");
			
			char * buf = new char[5000];
			
			ftruncate(fd, 10);
			
			close(fd);
		</Code>
		<Footer>
			close(fd);
		</Footer>
	</Test>
	<Test Name="xtTruncate_pmapFail">
		<Description>Brings to failure in xtTruncate_pmap function due to stack overflow.</Description>
		<Header>
			int fd = -1;
		</Header>
		<Code>
			
			const char * FilePath = "xtTruncate_pmapFail_test";
			int fd = open(FilePath, O_RDWR | O_CREAT | O_EXCL | O_LARGEFILE, S_IRUSR | S_IWUSR);
			
			Unres(fd == -1, "Cannot create file.");
			
			Unres(write(fd, "asdf", 4) == -1, "Cannot write to file.");
			
			close(fd);
			
			sync();
			
			Unres( OverflowStack(FilePath) == false, "Cannot prepare stack." );
			
			fd = open(FilePath, O_RDWR | O_LARGEFILE, S_IRUSR | S_IWUSR);
			Unres(fd == -1, "Cannot open file.");
			
			unlink(FilePath);
			
			fsync(fd);
			
			close(fd);
		</Code>
		<Footer>
			close(fd);
		</Footer>
	</Test>
	<Internal>
		bool OverflowStack(string FilePath)
		{
			JFSCtl jfs;
			int inode_num = jfs.GetInodeNum(FilePath);
			
			if(PartitionManager::ReleasePartition(MountPoint) == false)
				return false;
			
			dinode * inode = jfs.GetInode(DeviceName, inode_num);
			if (inode == NULL)
				return false;
			
			// Add too many levels to the xtree
			
			inode->di_size = (1 << 30);
			
			xtpage_t * page = (xtpage_t*)&inode->di_xtroot;
			page->header.flag = BT_ROOT | BT_INTERNAL;
			
			// Get the xad describing the data block
			xad x = ((xad*)inode->di_xtroot)[XTENTRYSTART];
			
			int64_t addr = addressXAD(&x);
			
			XADoffset(&((xad*)inode->di_xtroot)[XTENTRYSTART], 0);
			
			xtpage_t internal_page;

			// The page refers to itself.  During lookup it will cause an infinite loop :)
			memset(&internal_page, 0, sizeof(xtpage_t));
			XADoffset(&internal_page.xad[XTENTRYSTART], 0);
			XADaddress(&internal_page.xad[XTENTRYSTART], addr);
			internal_page.header.nextindex = XTENTRYSTART + 1;
			internal_page.header.maxentry = XTPAGEMAXSLOT;
			internal_page.header.flag = BT_INTERNAL;
			if ( jfs.WriteBlock(DeviceName, &internal_page, addr) == false )
				return false;
									
			if ( jfs.SetInode(DeviceName, inode_num, inode) == false )
				return false;
			
			if (PartitionManager::Mount(DeviceName, MountPoint, FileSystem, "", 0) == false )
				return false;
			
			if (chdir(MountPoint) == -1)
				return false;
			
			return true;
		}
	</Internal>
	<Footer>
		Fatal( PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem, true)!= PS_Success,"Mount failed" );
	</Footer>
</TestSet>
