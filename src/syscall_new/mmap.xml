<!--    mmap.xml
//      
//      Copyright (C) 2011, Institute for System Programming
//                          of the Russian Academy of Sciences (ISPRAS)
//      Author:
//			Ruzanna Karakozova <r.karakozova@gmail.com>			
//      
//      This program is free software; you can redistribute it and/or modify
//      it under the terms of the GNU General Public License as published by
//      the Free Software Foundation; either version 2 of the License, or
//      (at your option) any later version.
//      
//      This program is distributed in the hope that it will be useful,
//      but WITHOUT ANY WARRANTY; without even the implied warranty of
//      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//      GNU General Public License for more details.
//      
//      You should have received a copy of the GNU General Public License
//      along with this program; if not, write to the Free Software
//      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
//      MA 02110-1301, USA.
-->

<TestSet Name="mmap">
	<Requires>sys/mman.h</Requires>
	<Requires>sys/user.h</Requires>
	<Requires>linux/version.h</Requires>
	<Internal></Internal>
	<Test Name="MmapNormal">
		<Description>map files or devices into memory</Description>
		<File count="1"/>
		<Code>
		char * buff = (char *)"abc";
		if(write(FDs[0], buff, strlen(buff)) == -1)
		{
			Error("write failed", Unresolved);
 		}
		
		size_t length = strlen(buff);
		int prot = PROT_READ;
		int flags = MAP_PRIVATE;
		off_t offset = 0;
	
		void * addr = mmap(0, length, prot, flags, FDs[0], offset);
		if(addr == MAP_FAILED)
		{
			Error("System call mmap failed", Fail);
		}
		
		if(strncmp(buff, (char *)addr, strlen(buff)))
		{
			Error("System call mmap failed: mapped content differs from file content", Fail);
		}
		
		return Success;
		</Code>
	</Test>
	<Test Name="MmapErrInval">
		<Description>We don't like addr, length, or offset (e.g., they are too large, or not aligned on a page boundary)</Description>
		<File count="1"/>
		<Code>
		int status = Success;
		void * addr = 0;
		size_t length = 10;
		int prot = PROT_READ;
		int flags = MAP_PRIVATE;
		off_t offset = 0;
		
		addr = mmap(0, length, prot, flags, FDs[0], ~PAGE_MASK);
		if(addr != MAP_FAILED || errno != EINVAL)
		{
			Error("EINVAL error expected: offset contains invalid value");
			status = Fail;
		}
		
	#if  LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12)
		addr = mmap(0, 0, prot, flags, FDs[0], offset);
		if(addr != MAP_FAILED || errno != EINVAL)
		{
			Error("EINVAL error expected: length contains 0 value");
			status = Fail;
		}
	#endif
		
		addr = mmap(0, length, prot, MAP_PRIVATE | MAP_SHARED, FDs[0], offset);
		if(addr != MAP_FAILED || errno != EINVAL)
		{
			Error("EINVAL error expected: flags contains invalid value, MAP_PRIVATE and MAP_SHARED are set");
			status = Fail;
		}

		addr = mmap(0, length, prot, 0, FDs[0], offset);
		if(addr != MAP_FAILED || errno != EINVAL)
		{
			Error("EINVAL error expected: flags contains 0 value");
			status = Fail;	
		}
		
		return status;
		</Code>
	</Test>
	<Test Name="MmapErrBadF">
		<Description>fd is not a valid file descriptor  (and  MAP_ANONYMOUS  was  not set)</Description>
		<Code>
			
			size_t length = 10;
			int prot = PROT_READ;
			int flags = MAP_PRIVATE;
			off_t offset = 0;
			int fd = -1;
			
			ErrorTest(mmap(0, length, prot, flags, fd, offset), MAP_FAILED, EBADF);
		</Code>
	</Test>
	<Test Name="MmapErrAcces">
		<Description>MAP_PRIVATE was requested, but fd is not open for  reading. Or MAP_SHARED was  requested  and  PROT_WRITE  is  set,  but fd is not open in read/write (O_RDWR) mode</Description>
		<File count="1" flags="O_WRONLY | O_CREAT" mode="S_IRUSR | S_IWUSR"/>
		<Code>
			int status = Success;
			void * addr = 0;
			size_t length = 10;
			int prot = PROT_READ;
			int flags = MAP_PRIVATE;
			off_t offset = 0;

			addr = mmap(0, length, prot, flags, FDs[0], offset);		
			if(addr != MAP_FAILED || errno != EACCES)
			{
				Error("EACCES error expected: MAP_PRIVATE was requested, but fd is not opened for reading");
				status = Fail;
			}
			
			addr = mmap(0, length, PROT_WRITE, MAP_SHARED, FDs[0], offset);
			if(addr != MAP_FAILED || errno != EACCES)
			{
				Error("EACCES error expected: fd is not opened in read/write mode");
				status = Fail;
			}
			
			return status;
		</Code>
	</Test>
	<Test Name="MunmapNormal">
		<Description>munmap files or devices into memory</Description>
		<File count="1"/>
		<Code>
			size_t length = 3;
			int prot = PROT_READ;
			int flags = MAP_PRIVATE;
			off_t offset = 0;
		
			void * addr = mmap(0, length, prot, flags, FDs[0], offset);
			if(addr == MAP_FAILED)
			{
				Error("System call mmap failed", Unresolved);
			}
			
			if(munmap(addr, length) == -1)
			{
				Error("System call munmap failed", Fail);
			}
			
			return Success;
		</Code>
	</Test>
	<Test Name="MunmapErr">
		<Description>munmap() returns -1 on failure and errno is set (probably to EINVAL)</Description>
		<File count="1"/>
		<Code>
			int status = Success;
			size_t length = 3;
			int prot = PROT_READ;
			int flags = MAP_PRIVATE;
			off_t offset = 0;
		
			void * addr = mmap(0, length, prot, flags, FDs[0], offset);
			if(addr == MAP_FAILED)
			{
				Error("System call mmap failed", Unresolved);
			}
			
			if(munmap(addr, -1) != -1)
			{
				Error("Error expected: length contains invalid value");
				status = Fail;
			}
			
			int pageSize = getpagesize();
			if(munmap((void *)(pageSize + 1), length) != -1)
			{
				Error("Error expected: addr contains invalid value");
				status = Fail;
			}	
			
			return status;
		</Code>
	</Test>
</TestSet>
