<!--    access.xml
//      
//      Copyright (C) 2011, Institute for System Programming
//                          of the Russian Academy of Sciences (ISPRAS)
//      Author:
//			Vahram Martirosyan <vmartirosyan@gmail.com>
//      
//      This program is free software; you can redistribute it and/or modify
//      it under the terms of the GNU General Public License as published by
//      the Free Software Foundation; either version 2 of the License, or
//      (at your option) any later version.
//      
//      This program is distributed in the hope that it will be useful,
//      but WITHOUT ANY WARRANTY; without even the implied warranty of
//      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//      GNU General Public License for more details.
//      
//      You should have received a copy of the GNU General Public License
//      along with this program; if not, write to the Free Software
//      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
//      MA 02110-1301, USA.
-->

<TestSet Name="access">
	<Requires>sys/ioctl.h</Requires>
	<Requires>fcntl.h</Requires>
	<Requires>linux/fs.h</Requires>
	<Requires>pwd.h</Requires>				
	<Internal></Internal>
	<Test Name="AccessNormal" FaultSimulationReady="true">
		<Description>access()  checks  whether the calling process can access the file pathname.</Description>			
		<File count="1" />
		<Code>
			
			Unres(chmod(FilePaths[0].c_str(), 0777) == -1, "Cannot set permission flags on file." );
			
			
			struct passwd * nobody = getpwnam("nobody");
			
			Unres( nobody == NULL, "Cannot obtain nobody user information.");
			
			
			Unres ( setuid(nobody->pw_uid) == -1, "Cannot set the user ID to nobody.");
			
			
			if (access(FilePaths[0].c_str(), R_OK) == -1 )
			{
				Error("Read permission is granted but access returns error.", Fail);
			}
			
			if ( access(FilePaths[0].c_str(), W_OK) == -1 )
			{
				Error("Write permission is granted but access returns error. ", Fail);
			}
			
			if ( access(FilePaths[0].c_str(), X_OK) != 0 )
			{
				Error("Execution permission is granted but access returns error. ", Fail);
			}
			
			// Restore the user id to root
			if ( setuid(0) == -1 )
			{
				Error("Cannot set the user ID to root.");
			}
			
			return Success;
		</Code>
	</Test>
	<Test Name="AccessFileExists" FaultSimulationReady="true">
		<Description>the existence test (F_OK)</Description>			
		<File count="1" />
		<Code>
			if ( access(FilePaths[0].c_str(), F_OK) != 0 )
			{
				Error("The file exists but access returns error. ", Fail);
			}
			
			return Success;
		</Code>
	</Test>
	<Test Name="AccessErrAccess">
		<Description>Permission bits of the file mode do  not  permit  the  requested access.</Description>
		<File count="1" />
		<Code>
			struct passwd * nobody = getpwnam("nobody");
		
			Unres(nobody == NULL, "Cannot obtain nobody user information.");
			
			Unres( setuid(nobody->pw_uid) == -1, "Cannot set the effective user ID to nobody.");
			if ( access(FilePaths[0].c_str(), W_OK) == 0 || errno != EACCES )
			{
				Error("access should return EACCES error code but it did not.", Fail);
			}
			
			return Success;
		</Code>
	</Test>
	<Test Name="AccessErrLoop">
		<Description>A loop exists in symbolic links encountered during resolution of the path argument.</Description>			
		<File count="1" />
		<Code>
			Unres(symlink(FilePaths[0].c_str(), "new_file") == -1, "Cannot create symlink on old_file.");
			
			Unres( unlink(FilePaths[0].c_str()) == -1, "Cannot remove old_file. ");
			
			Unres( symlink("new_file", FilePaths[0].c_str()) == -1, "Cannot create symlink on new_file.");
			
			int res = access(FilePaths[0].c_str(), W_OK);
			
			unlink("new_file");
			
			if ( res == 0 || errno != ELOOP )
			{
				Error("access should return ELOOP error code but it did not.", Fail);
			}
			
			return Success;
		</Code>
	</Test>
	<Test Name="AccessErrNameTooLong">
		<Description>The length of the path argument exceeds {PATH_MAX} or a pathname component is longer than {NAME_MAX}.</Description>
		<Code>
		std::string filename = "asdf";
		for ( int i = 0; i < PATH_MAX; ++i )
			filename += "a";
			
		if ( access(filename.c_str(), W_OK) == 0 || errno != ENAMETOOLONG )
		{
			Error("access should return ENAMETOOLONG error code but it did not.", Fail);
		}
		
		return Success;
		</Code>
	</Test>
	<Test Name="AccessErrNoEnt">
		<Description>A component of path does not name an existing file or path is an empty string.</Description>
		<Code>
		if ( access("non_existing_file", W_OK) == 0 || errno != ENOENT )
		{
			Error("access should return ENOENT error code in case of non-existing file but it did not.", Fail);
		}
		if ( access("", W_OK) == 0 || errno != ENOENT )
		{
			Error("access should return ENOENT error code in case of empty file name but it did not.", Fail);
		}
		
		return Success;
		</Code>
	</Test>
	<Test Name="AccessErrNotDir">
		<Description>A component of the path prefix is not a directory.</Description>
		<Code>
		if ( access("not_a_dir_name/some_file", W_OK) == 0 || errno != ENOTDIR )
		{
			Error("access should return ENOTDIR error code but it did not.", Fail);
		}
		
		return Success;
		</Code>
	</Test>
	<FaultSimulation>
		<Simulate function="kmalloc" condition="" />
		<Simulate function="copy_to_user" condition="" />
		<!-- ... -->
	</FaultSimulation>
</TestSet>


