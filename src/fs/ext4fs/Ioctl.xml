<TestSet Name="Ioctl">
	<Requires>sys/ioctl.h</Requires>
	<Requires>linux/fs.h</Requires>
	<Requires>fcntl.h</Requires>
	<Requires>ext2fs/ext2_fs.h</Requires>	
	<Requires>pwd.h</Requires>
	<Requires>inttypes.h</Requires>
	<Test Name="SetFlagsGetFlags" FaultSimulationReady="true">		
		<Description>Try to set and get some flag values.</Description>
		<File count="1"/>
		<Code>
			int set_flags = /*EXT4_IMMUTABLE_FL |*/ 1; // We may NOT clear the extents flag...
			int get_flags = 0;
			
			// Backup the old values just in case
			int old_flags;	
			Unres( ioctl(FDs[0], EXT2_IOC_GETFLAGS, &old_flags ) == -1 , "Error backing up old values.");
			
			// Set our testing flag values
			Unres ( ioctl(FDs[0], EXT2_IOC_SETFLAGS, &set_flags ) == -1, "Error setting new flag values.");
		
			// Get the flags back
			Unres ( ioctl(FDs[0], EXT2_IOC_GETFLAGS, &get_flags ) == -1, "Error getting flag values back.");
			
			// Restore the original flags
			Unres ( ioctl(FDs[0], EXT2_IOC_SETFLAGS, &old_flags ) == -1, "Error restoring old flag values.");
			
			// Compare them
			Fail ( get_flags != set_flags, "Set and Get flags mismatch");
			
			;
		</Code>
	</Test>
	<Test Name="ClearExtentsFlags">
		<Description>Try to clear the Extentes flag which is not allowed to be cleared.</Description>
		<File count="1"/>
		<Code>
			// Backup the old values just in case
			int old_flags;
			Unres ( ioctl(FDs[0], EXT2_IOC_GETFLAGS, &old_flags ) == -1, "Error backing up old values.");
			if(!(old_flags && EXT4_EXTENTS_FL))
			{
				Error("Extent flag not supported",Unsupported);
			}
			int non_permitted_flags = old_flags & ~EXT4_EXTENTS_FL; // We may NOT clear the extents flag... but we shall try!
			EnableFaultSim();
			// Try to set the non-permitted flag
			Fail( ioctl(FDs[0], EXT2_IOC_SETFLAGS, &non_permitted_flags ) == 0, "It was permitted to set non-permitted flag!.");
							
		</Code>
	</Test>
	<Test Name="SetFlagsNotOwner">
		<Description>Try to perform a special operation not being file owner.</Description>
		<File count="1"/>
		<Code>
			int flags = EXT4_EXTENTS_FL;			
			
			ENoAccessTest(ioctl(FDs[0], EXT2_IOC_SETFLAGS, &flags ), -1);			
		</Code>
	</Test>
	<Test Name="SetVersionGetVersion" FaultSimulationReady="true">
		<Description>Get and set version.</Description>
		<File count="1"/>
		<Code>
			int set_version = 10; 
			int get_version = 0;
			
			// Backup the old version just in case
			int old_version;
			Unres ( ioctl(FDs[0], EXT2_IOC_GETVERSION, &old_version) == -1, "Error backing up old version.");
			
			// Set our testing version value
			Unres ( ioctl(FDs[0], EXT2_IOC_SETVERSION, &set_version) == -1, "Error setting new version values.");
			
			// Get the version back
			Unres ( ioctl(FDs[0], EXT2_IOC_GETVERSION, &get_version) == -1, "Error getting version value back.");
			
			// Restore the original version
			Unres ( ioctl(FDs[0], EXT2_IOC_SETVERSION, &old_version) == -1, "Error restoring old version value.");
			
			// Compare them
			Fail ( get_version != set_version, "Set and Get version mismatch");
			;				
		</Code>
	</Test>
	<!-- This commang is removed in newer kernels... -->
	<Test Name="WaitForReadonly" FaultSimulationReady="true" Shallow="true">

		<Description>Wait for read only.</Description>
		<File count="1"/>
		<Code>
#if  LINUX_VERSION_CODE > KERNEL_VERSION(3,1,0)
		Unsupp("Wait for read only operation is unsupported in Linux 3.1+ versions.");
#else
#ifndef EXT4_IOC_WAIT_FOR_READONLY
#define EXT4_IOC_WAIT_FOR_READONLY	_IOR('f', 99, long)
#endif
			EnableFaultSim();
			if ( ioctl(FDs[0], EXT4_IOC_WAIT_FOR_READONLY, NULL) == -1 )
			{
				if ( errno == ENOTTY )
				{
					Error("EXT4_IOC_WAIT_FOR_READONLY is not supported.", Unsupported);
				}
				else
				{
					Error("Error waiting for readonly.", Fail);
				}
			}
#endif
		</Code>		
	</Test>
	<Test Name="GroupExtend" FaultSimulationReady="true" Shallow="true">
		<Description>Group extend.</Description>
		<File count="1"/>
		<Code>
			struct stat st;
			Unres ( fstat (FDs[0], &st ) == -1, "Cannot stat file " + static_cast<string>(MountPoint));
		
			ioctl(FDs[0], EXT2_IOC_GROUP_EXTEND, 0);//covering code
			int NewPartitionSizeInBlocks = PartitionManager::GetDeviceSize(DeviceName)/4096+50000;
			if(ioctl(FDs[0], EXT2_IOC_GROUP_EXTEND, &NewPartitionSizeInBlocks) == -1)
			{
				cerr << "Error during online resize. " << strerror(errno);
				Return(Fail);
			}
		
			//Status status;
			
			/*NewPartitionSizeInBlocks -= 2;
			if ( ioctl(FDs[0], EXT2_IOC_GROUP_EXTEND, &NewPartitionSizeInBlocks) == -1 )
			{
				cerr << "Error during online resize. " << strerror(errno);
				Return(Fail);
			}
			else
			{
				cerr << "Online resize was successful. " << endl;
			}*/
		</Code>
	</Test>
	<Test Name="ResizeFS" FaultSimulationReady="true" Shallow="true">
		<Requires KernelVersion="3,3,0" />
		<Description>Resize FS.</Description>
		<File count="1"/>
		<Code>
#ifndef EXT4_IOC_RESIZE_FS
#	define EXT4_IOC_RESIZE_FS              _IOW('f', 16, __u64)
#endif
			uint64_t DeviceSize;
			struct stat st;
			Unres ( stat(DeviceName, &st) == -1, "Cannot get file stats.");
				
			if (S_ISREG(st.st_mode))
			{
				DeviceSize = st.st_size;
			}
			else
			{
				int fd = open(DeviceName, O_RDONLY);
				Unres (fd == -1, "Cannot open partition");
				
				Unres ( ioctl( fd, BLKGETSIZE64, &DeviceSize ) == -1, "Cannot get partition size.");

				close(fd);
			}
			
			__u64 BlockCount = DeviceSize / 4096;
			Fail(ioctl(FDs[0], EXT4_IOC_RESIZE_FS, &BlockCount) == -1, "Resize FS failed");
		</Code>
	</Test>
	<Test Name="MoveExtent" FaultSimulationReady="true" Shallow="true">
		<Description>Move extent.</Description>
		<File count="2"/>
		<Code>
#ifndef EXT4_IOC_MOVE_EXT
struct move_extent {
	__u32 reserved;		/* should be zero */
	__u32 donor_fd;		/* donor file descriptor */
	__u64 orig_start;	/* logical start offset in block for orig */
	__u64 donor_start;	/* logical start offset in block for donor */
	__u64 len;		/* block length to be moved */
	__u64 moved_len;	/* moved block length */
};
#define EXT4_IOC_MOVE_EXT		_IOWR('f', 15, struct move_extent)
#endif
			Unres (unlink(FilePaths[0].c_str()) == -1, "Cannot unlink the donor file.");
			
			Unres ( fallocate(FDs[0], 0, 0, 32000*2*4096), "Cannot allocate space for donor file.");
			
			Unres ( fallocate(FDs[1], 0, 0, 32000*2*4096), "Cannot allocate space for original file.");
			
			//unsigned int BlockCount = 1;
			
			struct move_extent me;
			memset(&me, 0, sizeof(me));
			me.donor_fd = FDs[0];
			me.orig_start = 0;
			me.donor_start = 0;
			me.len = 2;
			me.moved_len = 0;
			
			
			Fail ( ioctl(FDs[1], EXT4_IOC_MOVE_EXT, &me) == -1 , "Error moving extent.");
			
		</Code>
	</Test>
	<Test Name="GroupAdd" FaultSimulationReady="true" Shallow="true">
		<Description>Group add.</Description>
		<File count="1"/>
		<Code>
struct ext4_new_group_data {
	__u32 group;
	__u64 block_bitmap;
	__u64 inode_bitmap;
	__u64 inode_table;
	__u32 blocks_count;
	__u16 reserved_blocks;
	__u16 unused;
	__u32 free_blocks_count;
};
#ifndef EXT4_IOC_GROUP_ADD
#define EXT4_IOC_GROUP_ADD		_IOW('f', 8, struct ext4_new_group_input)
#endif
			struct ext4_new_group_input input;
			memset(&input, 0, sizeof(input));			
						
			ioctl(FDs[0], EXT4_IOC_GROUP_ADD, &input);
			
		</Code>
	</Test>
	<Test Name="Migrate" FaultSimulationReady="true" Shallow="true">
		<Description>Migrate an Ext3 partition to Ext4</Description>
		<StartUp>
			// Temporary solution. Should be removed as soon as the logic of test execution is changed.		
			if ( !PartitionManager::NoMountOptionsEnabled() )
				goto CleanUp;		
		</StartUp>
		<Header>
#ifndef EXT4_IOC_MIGRATE
#	define EXT4_IOC_MIGRATE		_IO('f', 9)
#endif

#ifdef	COMPAT
			Unsupp("Not supported in COMPAT mode.");
#endif	
			Unres ( !PartitionManager::ReleasePartition(MountPoint) , "Unmount failed!");

		</Header>
		<Code>
			int _file = -1;
			UnixCommand mkfs("mkfs.ext3");
			vector<string> args;
			args.push_back(DeviceName);
			ProcessResult * res;
			res = mkfs.Execute(args);
			Unres ( res == NULL || res->GetStatus() != Success, "Cannot create ext3 filesystem on device " + (string)DeviceName);
		
			UnixCommand tunefs("tune2fs");
			args.erase(args.begin(),args.end());
			args.push_back("-O");
			args.push_back("extents");
			args.push_back(DeviceName);
			
			res = tunefs.Execute(args);
			Unres ( res == NULL || res->GetStatus() != Success, "Cannot tune ext3 filesystem on device " + (string)DeviceName);
			
			delete res;
			Unres ( mount( DeviceName, MountPoint, "ext4", 0, 0) == -1, "Cannot mount ext3 FS " + (string)DeviceName + " to " + (string)MountPoint);
			Unres ( chdir(MountPoint) != 0,"Cannot change current dir to " );

			Unres( (_file = open(MountPoint, O_DIRECTORY | O_RDONLY)) == -1, "Cannot open dir");
			
			Fail ( ioctl(_file, EXT4_IOC_MIGRATE, 0) == -1,"Error migrating!" );
			
		</Code>
		<CleanUp>
			if (_file != -1)
				close(_file);
			if( PartitionManager::RestorePartition(DeviceName, MountPoint, FileSystem, true)!= PS_Success )
			{
				Error("Restore failed!");
				_exit(Fatal);
			}
		</CleanUp>
	</Test>
	<Test Name="AllocDABlocks" FaultSimulationReady="true" Shallow="true">
		<Description>Allocate delayed-allocation blocks.</Description>
		<File count="1"/>
		<Code>
#ifndef EXT4_IOC_ALLOC_DA_BLKS
#define EXT4_IOC_ALLOC_DA_BLKS		_IO('f', 12)
#endif

#ifdef	COMPAT
		Unsupp("Not supported in COMPAT mode.");
#else
		Fail ( ioctl(FDs[0], EXT4_IOC_ALLOC_DA_BLKS, 0) == -1, "Error during delayed allocation of blocks.");
#endif	
		</Code>
	</Test>
	<Test Name="Fitrim" FaultSimulationReady="true" Shallow="true">
		<Requires Defined="FITRIM" />
		<Description>FITRIM?</Description>
		<File count="1"/>
		<Code>
			struct fstrim_range arg;
			Fail ( ioctl(FDs[0], FITRIM, &arg) == -1 , "Error FITRIM.");
		</Code>
	</Test>
	<Test Name="Unsupported">
		<Description>Unsupported operation.</Description>
		<File count="1"/>
		<Code>
			ErrorTest(ioctl(FDs[0], -100, 0), -1, ENOTTY);
		</Code>
	</Test>
</TestSet>
