<TestSet Name="Ioctl">
	<Requires>sys/ioctl.h</Requires>
	<Requires>fcntl.h</Requires>
	<Requires>ext4.hpp</Requires>
	<Requires>pwd.h</Requires>
	<Test Name="SetFlagsGetFlags" FaultSimulationReady="true">		
		<Description>Try to set and get some flag values.</Description>
		<File count="1"/>
		<Code>
			int set_flags = EXT4_EXTENTS_FL | 1; // We may NOT clear the extents flag...
			int get_flags = 0;
			
			// Backup the old values just in case
			int old_flags;	
			Unres( ioctl(FDs[0], EXT4_IOC_GETFLAGS, &old_flags ) == -1 , "Error backing up old values.");
			
			// Set our testing flag values
			Unres ( ioctl(FDs[0], EXT4_IOC_SETFLAGS, &set_flags ) == -1, "Error setting new flag values.");
		
			// Get the flags back
			Unres ( ioctl(FDs[0], EXT4_IOC_GETFLAGS, &get_flags ) == -1, "Error getting flag values back.");
			
			// Restore the original flags
			Unres ( ioctl(FDs[0], EXT4_IOC_SETFLAGS, &old_flags ) == -1, "Error restoring old flag values.");
			
			// Compare them
			Fail ( get_flags != set_flags, "Set and Get flags mismatch");
			
			return Success;			
		</Code>
	</Test>
	<Test Name="ClearExtentsFlags">
		<Description>Try to clear the Extentes flag which is not allowed to be cleared.</Description>
		<File count="1"/>
		<Code>
			// Backup the old values just in case
			int old_flags;
			Unres ( ioctl(FDs[0], EXT4_IOC_GETFLAGS, &old_flags ) == -1, "Error backing up old values.");
			
			int non_permitted_flags = old_flags & ~EXT4_EXTENTS_FL; // We may NOT clear the extents flag... but we shall try!
			
			// Try to set the non-permitted flag
			Fail( ioctl(FDs[0], EXT4_IOC_SETFLAGS, &non_permitted_flags ) == -1, "It was permitted to set non-permitted flag!.");
			
			return Success;						
		</Code>
	</Test>
	<Test Name="SetFlagsNotOwner">
		<Description>Try to perform a special operation not being file owner.</Description>
		<File count="1"/>
		<Code>
			int flags = EXT4_EXTENTS_FL;			
			
			ENoAccessTest(ioctl(FDs[0], EXT4_IOC_SETFLAGS, &flags ), -1);			
		</Code>
	</Test>
	<Test Name="SetVersionGetVersion" FaultSimulationReady="true">
		<Description>Get and set version.</Description>
		<File count="1"/>
		<Code>
			int set_version = 10; 
			int get_version = 0;
			
			// Backup the old version just in case
			int old_version;
			Unres ( ioctl(FDs[0], EXT4_IOC_GETVERSION, &old_version) == -1, "Error backing up old version.");
			
			// Set our testing version value
			Unres ( ioctl(FDs[0], EXT4_IOC_SETVERSION, &set_version) == -1, "Error setting new version values.");
			
			// Get the version back
			Unres ( ioctl(FDs[0], EXT4_IOC_GETVERSION, &get_version) == -1, "Error getting version value back.");
			
			// Restore the original version
			Unres ( ioctl(FDs[0], EXT4_IOC_SETVERSION, &old_version) == -1, "Error restoring old version value.");
			
			// Compare them
			Fail ( get_version != set_version, "Set and Get version mismatch");
			return Success;				
		</Code>
	</Test>
	<Test Name="WaitForReadonly" FaultSimulationReady="true">
		<Description>Wait for read only.</Description>
		<File count="1"/>
		<Code>
			Fail ( ioctl(FDs[0], EXT4_IOC_WAIT_FOR_READONLY, NULL) == -1, "Error waiting for readonly.");
			return Shallow;
		</Code>
	</Test>
	<Test Name="GroupExtend" FaultSimulationReady="true">
		<Description>Group extend.</Description>
		<File count="1"/>
		<Code>
			struct stat st;
			Unres ( fstat (FDs[0], &st ) == -1, "Cannot stat file " + (string)MountPoint);
		
			cerr << "Shallow test";
			int NewPartitionSizeInBlocks = 210000;
			ioctl(FDs[0], EXT4_IOC_GROUP_EXTEND, &NewPartitionSizeInBlocks);
			
			return Shallow;
			
			//Status status;
			
			/*NewPartitionSizeInBlocks = 210000;// _PartitionSizeInBlocks + 10;
			if ( ioctl(FDs[0], EXT4_IOC_GROUP_EXTEND, &NewPartitionSizeInBlocks) == -1 )
			{
				cerr << "Error during online resize. " << strerror(errno);
				return Failure;
			}
			else
			{
				cerr << "Online resize was successful. " << endl;
				return Success;
			}*/
		</Code>
	</Test>
	<Test Name="MoveExtent" FaultSimulationReady="true">
		<Description>Move extent.</Description>
		<File count="2"/>
		<Code>			
			Unres (unlink(FilePaths[0].c_str()) == -1, "Cannot unlink the donor file.");
			
			Unres ( fallocate(FDs[0], 0, 0, 10*4096), "Cannot allocate space for donor file.");
			
			Unres ( fallocate(FDs[1], 0, 0, 10*4096), "Cannot allocate space for original file.");
			
			//unsigned int BlockCount = 1;
			
			struct move_extent me;
			memset(&me, 0, sizeof(me));
			me.donor_fd = FDs[0];
			me.orig_start = 0;
			me.donor_start = 0;
			me.len = 10;
			me.moved_len = 10;
			
			
			Fail ( ioctl(FDs[1], EXT4_IOC_MOVE_EXT, &me) == -1 , "Error moving extent.");
			return Success;
		</Code>
	</Test>
	<Test Name="GroupAdd" FaultSimulationReady="true">
		<Description>Group add.</Description>
		<File count="1"/>
		<Code>
			struct ext4_new_group_data input;
			//memset(&input, 0, sizeof(input));		
			
			cerr << "Shallow test" << endl;
			ioctl(FDs[0], EXT4_IOC_GROUP_ADD, &input);
			
			return Shallow;		
		</Code>
	</Test>
	<Test Name="Migrate" FaultSimulationReady="true">
		<Header>
			Status result = Unknown;
		</Header>
		<Code>
			Unres ( chdir ("/") == -1 , "Cannot change directory.");
			
			//if ( umount2( MountPoint, MNT_FORCE ) == -1 )	
			Unres ( umount( MountPoint ) == -1, "Cannot unmount " + (string)MountPoint);
			
			//cerr << ("mkfs.ext2 " + _DeviceName).c_str() << endl;
			
			UnixCommand mkfs("mkfs.ext3");
			vector<string> args;			
			//args.push_back("-O");
			//args.push_back("extents");
			args.push_back(DeviceName);
			
			ProcessResult * res;
			res = mkfs.Execute(args);
			Unres ( res == NULL || res->GetStatus() != Success, "Cannot create ext3 filesystem on device " + (string)DeviceName);
			
			Unres ( mount( DeviceName, MountPoint, "ext3", 0, 0) == -1, "Cannot mount ext3 FS " + (string)DeviceName + " to " + (string)MountPoint);
			
			Directory mountFile(MountPoint, O_DIRECTORY | O_RDONLY);
			int _file = mountFile.GetDirectoryDescriptor();
		
			if ( _file == -1 )
			{
				cerr << "Cannot open folder: " << MountPoint << ". Error : " << strerror(errno);
				result = Unresolved;
				goto finally;
			}
			
			
			if ( ioctl(_file, EXT4_IOC_MIGRATE, 0) == -1 )
			{
				cerr << "Error migrating. " << strerror(errno) << endl;
				result = Fail;
				goto finally;
			}
			else
			{
				cerr << "Migration was successful. " << endl;
				result = Success;
				goto finally;
			}
			return Success;
		</Code>
		<Footer>
			finally:
			if ( umount( MountPoint ) == -1 )
			{
				Error("Cannot unmount " + (string)MountPoint, Fatal);
			}
			
			UnixCommand mkfs2("mkfs.ext4");
			vector<string> args2;		
			args2.push_back(DeviceName);
			
			ProcessResult * res2;
			res2 = mkfs2.Execute(args2);
			if ( res2->GetStatus() != Success )
			{
				Error("Cannot create ext4 filesystem on device " + (string)DeviceName + " Error: " + res2->GetOutput(), Fatal);
			}
			
			//system(("mkfs.ext2 " + _DeviceName).c_str());
			if ( mount( MountPoint, DeviceName, "ext4", 0, 0) == -1)
			{
				Error("Cannot mount " + (string)DeviceName + " back to " + MountPoint, Fatal);
			}
			return result;
		</Footer>
	</Test>
	<Test Name="AllocDABlocks" FaultSimulationReady="true">
		<Description>Allocate delayed-allocation blocks.</Description>
		<File count="1"/>
		<Code>
			Fail ( ioctl(FDs[0], EXT4_IOC_ALLOC_DA_BLKS, 0) == -1, "Error during delayed allocation of blocks.");
			return Shallow;
			
		</Code>
	</Test>
	<Test Name="Fitrim" FaultSimulationReady="true">
		<Dessription>FITRIM?</Dessription>
		<File count="1"/>
		<Header>
#ifdef FITRIM
		</Header>
		<Code>				
			Fail ( ioctl(FDs[0], FITRIM, 0) == -1 , "Error FITRIM.");
			return Shallow;				
		</Code>
		<Footer>
#else
	Error("FITRIM is not supported", Unsupported);
#endif
		</Footer>
	</Test>
	<Test Name="Unsupported">
		<Description>Unsupported operation.</Description>
		<File count="1"/>
		<Code>
			ErrorTest(ioctl(FDs[0], -100, 0), -1, ENOTTY);
		</Code>
	</Test>
</TestSet>
