Генератор отчета тестирования

ПРЕРЕКВИЗИТЫ:

- Perl
- модуль Perl XML::Parser (для разбора журнала тестирования Spruce)
- модуль Perl HTML::Template (для генерации файла отчета index.html по шаблону)

Модули беруться из http://www.cpan.org, там же описана их установка.

ИСПОЛЬЗОВАНИЕ:

    report.pl [OPTIONS] <result_dir>

Генерирует файлы отчета в директории <result_dir>.

Опции:
    --problem-db <problem-db-file>
        Путь к файлу с базой данных известных проблем. По-умолчанию
        используется файл problem_db из директории с скриптом.
    --no-problem-db
        Не использовать базу данных известных проблем.
    --journals-dir <journals-dir>
        Путь к директории с журналами тестирования. По-умолчанию
        используется текущая директория (из которой запускается скрипт).
    --known-are-quelled
        Все известные ошибки автоматически подавляются. Эквивалентно
        добавлению строчки "attribute quell" в определение каждой
        проблемы в файл базы данных известных проблем. Полезно при
        визуальном поиске неизвестных ошибок.

ФОРМАТ БАЗЫ ДАННЫХ ИЗВЕСТНЫХ ПРОБЛЕМ

1.  Пустые строчки, строчки содержащие только пробелы и строчки,
    начинающиеся с '#', игнорируются.

2.  Все остальные строчки должны начинаться с ключевого слова,
    отделенного от остального содержимого строки пробелом(пробелами).

3.  Определение проблемы начинается с строчки вида:

test {testname} {testpoint}

Для Spruce под {testname} подразумевается имя семейства тестов
(например, read_write), под {testpoint} - имя конкретного теста
(например, ReadWriteDirect).

Определение теста заканчивается строчкой:

end

4. Для определения, известная ли проблема или нет, проверяются значения
свойств теста. Это могут быть свойства конкретного теста, группы тестов,
или тестируемой системы.
Привязка определения к тесту выполняется только тогда, когда все
проверки истинны. Если проверяемое свойство отсутствует у теста, то
проверка автоматически ложна.

4.0. Свойства теста для Spruce:

severity - результат теста. Значения serverity, к которым можно
    привязываться на данный момент:
    
    "Failed" - соответствует статусу теста "Failed"
    "Unresolved" - соответствует статусам теста "Unresolved", "Signaled"
    "Time expired" - соответствует статусу теста "Timeout"
    
    Следующие значения severity не являются сигналом проблемы, поэтому
    к ним привязываться не надо:
    
    "Passed" - соответствует статусам теста "Success" и "Shallow"
    "Unsupported" - соответствует статусу теста "Unsupported"

test_messages - сообщения, выводимые в тесте(многострочное значение).

fs - файловая система, для которой выполнялся тест (например, jfs).

mount_opts - опции монтирования файловой системы, с которыми выполнялся тест.
Пустая строчка соответствует монтированию без дополнительных опций.

test_suite - набор тестов (например, syscall).

arch - архитектура тестовой системы, x86 или x86_64.

code_bits - для 64-битной тестовой системы содержит битность кода теста, 32 или 64.

distro - имя дистрибутива Linux на тестовой системе.

distro_version - версия дистрибутива Linux на тестовой системе.

kernel_version - версия ядра Linux на тестовой системе.


4.1. Проверка, что свойство имеет конкретное значение:

expected {property} {value}

Например,

expected severity Failed

проверяет, что результат теста "Failed".

expected fs ext4

проверяет, что тест выполнялся для файловой системы ext4

4.2. Проверка, что свойство содержит заданную подстроку:

matched {property} {substring}

Например,

matched test_messages Error: Invalid argument

проверяет, что в сообщениях теста есть (под)строчка "Error: Invalid Argument"

4.3. Проверка, что версия, являющаяся значением свойства, будучи в левой
    части, удовлетворяет неравенству с определенным значением в правой части:

version l|le|g|ge {property} {value}

l - меньше
le - меньше или равно
g - больше
ge - больше или равно

Например,

version l kernel_version 3.0

проверяет, что версия ядра меньше 3.0 (то есть 2.6.*).


4.4. Одна проверка "expected" должна содержать severity в качестве
    проверяемого свойства. Также желательно, чтобы как минимум одна
    проверка "matched" или "expected" содержала test_messages в качестве
    проверяемого свойства.

Эти ограничения служат защитой от забытых проверок в записи проблемы.


5. В случае привязки определения проблемы к тесту, есть возможность
    определить дополнительные аттрибуты проблемы. Значения определенных
    атрибутов влияют на содержимое отчета о тестировании.

5.0. Стандартные атрибуты проблемы

resolution - Краткое описание источника проблемы. Желательно
    использовать одну из стандартных фраз:

    - "Test deficiency" - проблема в самом тесте. Ожидается, что тест
        будет переделан в скором будущем и проблема исчезнет.
    - "Filesystem problem" - проблема в драйвере конкретной файловой
        системы. В такого рода проблемах обычно идет привязка по свойству "fs".
    - "Kernel problem" - проблема в ядре. Например, VFS неправильно
        интерпритирует код ошибки, возвращаемый из драйвера.
    - "Libc problem" - проблема в библиотеке libc. Например, вызывается
        неправильный системный вызов, или неправильно интерпритируется
        возвращаемое им значение.

comments - комментарий к проблеме (когда проявляется, в чем именно
    причина проблемы, URL заведенного багрепорта, и т.д.).
    Следует учитывать, что привязки записи к тесту используются только
    при проверке, подходит ли описание к тесту или нет, и не видны
    пользователю. Поэтому все привязки должны быть упомянуты в
    комментарии к проблеме:
        "Ядро версии до 2.6.38 не поддерживает данную функциональность"

quell - индикатор, что ошибка подавляется.
    Подавляемые ошибки все равно выводятся в списке проблем, но они
    относятся не к "Failed", а к "Quelled", и не влияют на общий результат
    тестирования.

5.1. Определение аттрибута с заданным значением:

attribute {name}[ {value}]

Если значение опущено, то оно считается пустой строкой.

Если для одного аттрибута есть несколько таких строчек, то определяется
многострочный аттрибут.

Примеры:

attribute comments Error occures because function foo() incorrectly interprets
attribute comments its first argument.

attribute quell
